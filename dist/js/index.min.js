/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(8);
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */


function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && typeof val === 'object';
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */


function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function merge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */


function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }

  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.6.12
 * (c) 2014-2020 Evan You
 * Released under the MIT License.
 */
!function (e, t) {
   true ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self).Vue = t();
}(this, function () {
  "use strict";

  var e = Object.freeze({});

  function t(e) {
    return null == e;
  }

  function n(e) {
    return null != e;
  }

  function r(e) {
    return !0 === e;
  }

  function i(e) {
    return "string" == typeof e || "number" == typeof e || "symbol" == typeof e || "boolean" == typeof e;
  }

  function o(e) {
    return null !== e && "object" == typeof e;
  }

  var a = Object.prototype.toString;

  function s(e) {
    return "[object Object]" === a.call(e);
  }

  function c(e) {
    var t = parseFloat(String(e));
    return t >= 0 && Math.floor(t) === t && isFinite(e);
  }

  function u(e) {
    return n(e) && "function" == typeof e.then && "function" == typeof e.catch;
  }

  function l(e) {
    return null == e ? "" : Array.isArray(e) || s(e) && e.toString === a ? JSON.stringify(e, null, 2) : String(e);
  }

  function f(e) {
    var t = parseFloat(e);
    return isNaN(t) ? e : t;
  }

  function p(e, t) {
    for (var n = Object.create(null), r = e.split(","), i = 0; i < r.length; i++) n[r[i]] = !0;

    return t ? function (e) {
      return n[e.toLowerCase()];
    } : function (e) {
      return n[e];
    };
  }

  var d = p("slot,component", !0),
      v = p("key,ref,slot,slot-scope,is");

  function h(e, t) {
    if (e.length) {
      var n = e.indexOf(t);
      if (n > -1) return e.splice(n, 1);
    }
  }

  var m = Object.prototype.hasOwnProperty;

  function y(e, t) {
    return m.call(e, t);
  }

  function g(e) {
    var t = Object.create(null);
    return function (n) {
      return t[n] || (t[n] = e(n));
    };
  }

  var _ = /-(\w)/g,
      b = g(function (e) {
    return e.replace(_, function (e, t) {
      return t ? t.toUpperCase() : "";
    });
  }),
      $ = g(function (e) {
    return e.charAt(0).toUpperCase() + e.slice(1);
  }),
      w = /\B([A-Z])/g,
      C = g(function (e) {
    return e.replace(w, "-$1").toLowerCase();
  });
  var x = Function.prototype.bind ? function (e, t) {
    return e.bind(t);
  } : function (e, t) {
    function n(n) {
      var r = arguments.length;
      return r ? r > 1 ? e.apply(t, arguments) : e.call(t, n) : e.call(t);
    }

    return n._length = e.length, n;
  };

  function k(e, t) {
    t = t || 0;

    for (var n = e.length - t, r = new Array(n); n--;) r[n] = e[n + t];

    return r;
  }

  function A(e, t) {
    for (var n in t) e[n] = t[n];

    return e;
  }

  function O(e) {
    for (var t = {}, n = 0; n < e.length; n++) e[n] && A(t, e[n]);

    return t;
  }

  function S(e, t, n) {}

  var T = function (e, t, n) {
    return !1;
  },
      E = function (e) {
    return e;
  };

  function N(e, t) {
    if (e === t) return !0;
    var n = o(e),
        r = o(t);
    if (!n || !r) return !n && !r && String(e) === String(t);

    try {
      var i = Array.isArray(e),
          a = Array.isArray(t);
      if (i && a) return e.length === t.length && e.every(function (e, n) {
        return N(e, t[n]);
      });
      if (e instanceof Date && t instanceof Date) return e.getTime() === t.getTime();
      if (i || a) return !1;
      var s = Object.keys(e),
          c = Object.keys(t);
      return s.length === c.length && s.every(function (n) {
        return N(e[n], t[n]);
      });
    } catch (e) {
      return !1;
    }
  }

  function j(e, t) {
    for (var n = 0; n < e.length; n++) if (N(e[n], t)) return n;

    return -1;
  }

  function D(e) {
    var t = !1;
    return function () {
      t || (t = !0, e.apply(this, arguments));
    };
  }

  var L = "data-server-rendered",
      M = ["component", "directive", "filter"],
      I = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch"],
      F = {
    optionMergeStrategies: Object.create(null),
    silent: !1,
    productionTip: !1,
    devtools: !1,
    performance: !1,
    errorHandler: null,
    warnHandler: null,
    ignoredElements: [],
    keyCodes: Object.create(null),
    isReservedTag: T,
    isReservedAttr: T,
    isUnknownElement: T,
    getTagNamespace: S,
    parsePlatformTagName: E,
    mustUseProp: T,
    async: !0,
    _lifecycleHooks: I
  },
      P = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

  function R(e, t, n, r) {
    Object.defineProperty(e, t, {
      value: n,
      enumerable: !!r,
      writable: !0,
      configurable: !0
    });
  }

  var H = new RegExp("[^" + P.source + ".$_\\d]");
  var B,
      U = ("__proto__" in {}),
      z = "undefined" != typeof window,
      V = "undefined" != typeof WXEnvironment && !!WXEnvironment.platform,
      K = V && WXEnvironment.platform.toLowerCase(),
      J = z && window.navigator.userAgent.toLowerCase(),
      q = J && /msie|trident/.test(J),
      W = J && J.indexOf("msie 9.0") > 0,
      Z = J && J.indexOf("edge/") > 0,
      G = (J && J.indexOf("android"), J && /iphone|ipad|ipod|ios/.test(J) || "ios" === K),
      X = (J && /chrome\/\d+/.test(J), J && /phantomjs/.test(J), J && J.match(/firefox\/(\d+)/)),
      Y = {}.watch,
      Q = !1;
  if (z) try {
    var ee = {};
    Object.defineProperty(ee, "passive", {
      get: function () {
        Q = !0;
      }
    }), window.addEventListener("test-passive", null, ee);
  } catch (e) {}

  var te = function () {
    return void 0 === B && (B = !z && !V && "undefined" != typeof global && global.process && "server" === global.process.env.VUE_ENV), B;
  },
      ne = z && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  function re(e) {
    return "function" == typeof e && /native code/.test(e.toString());
  }

  var ie,
      oe = "undefined" != typeof Symbol && re(Symbol) && "undefined" != typeof Reflect && re(Reflect.ownKeys);
  ie = "undefined" != typeof Set && re(Set) ? Set : function () {
    function e() {
      this.set = Object.create(null);
    }

    return e.prototype.has = function (e) {
      return !0 === this.set[e];
    }, e.prototype.add = function (e) {
      this.set[e] = !0;
    }, e.prototype.clear = function () {
      this.set = Object.create(null);
    }, e;
  }();

  var ae = S,
      se = 0,
      ce = function () {
    this.id = se++, this.subs = [];
  };

  ce.prototype.addSub = function (e) {
    this.subs.push(e);
  }, ce.prototype.removeSub = function (e) {
    h(this.subs, e);
  }, ce.prototype.depend = function () {
    ce.target && ce.target.addDep(this);
  }, ce.prototype.notify = function () {
    for (var e = this.subs.slice(), t = 0, n = e.length; t < n; t++) e[t].update();
  }, ce.target = null;
  var ue = [];

  function le(e) {
    ue.push(e), ce.target = e;
  }

  function fe() {
    ue.pop(), ce.target = ue[ue.length - 1];
  }

  var pe = function (e, t, n, r, i, o, a, s) {
    this.tag = e, this.data = t, this.children = n, this.text = r, this.elm = i, this.ns = void 0, this.context = o, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = t && t.key, this.componentOptions = a, this.componentInstance = void 0, this.parent = void 0, this.raw = !1, this.isStatic = !1, this.isRootInsert = !0, this.isComment = !1, this.isCloned = !1, this.isOnce = !1, this.asyncFactory = s, this.asyncMeta = void 0, this.isAsyncPlaceholder = !1;
  },
      de = {
    child: {
      configurable: !0
    }
  };

  de.child.get = function () {
    return this.componentInstance;
  }, Object.defineProperties(pe.prototype, de);

  var ve = function (e) {
    void 0 === e && (e = "");
    var t = new pe();
    return t.text = e, t.isComment = !0, t;
  };

  function he(e) {
    return new pe(void 0, void 0, void 0, String(e));
  }

  function me(e) {
    var t = new pe(e.tag, e.data, e.children && e.children.slice(), e.text, e.elm, e.context, e.componentOptions, e.asyncFactory);
    return t.ns = e.ns, t.isStatic = e.isStatic, t.key = e.key, t.isComment = e.isComment, t.fnContext = e.fnContext, t.fnOptions = e.fnOptions, t.fnScopeId = e.fnScopeId, t.asyncMeta = e.asyncMeta, t.isCloned = !0, t;
  }

  var ye = Array.prototype,
      ge = Object.create(ye);
  ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function (e) {
    var t = ye[e];
    R(ge, e, function () {
      for (var n = [], r = arguments.length; r--;) n[r] = arguments[r];

      var i,
          o = t.apply(this, n),
          a = this.__ob__;

      switch (e) {
        case "push":
        case "unshift":
          i = n;
          break;

        case "splice":
          i = n.slice(2);
      }

      return i && a.observeArray(i), a.dep.notify(), o;
    });
  });

  var _e = Object.getOwnPropertyNames(ge),
      be = !0;

  function $e(e) {
    be = e;
  }

  var we = function (e) {
    var t;
    this.value = e, this.dep = new ce(), this.vmCount = 0, R(e, "__ob__", this), Array.isArray(e) ? (U ? (t = ge, e.__proto__ = t) : function (e, t, n) {
      for (var r = 0, i = n.length; r < i; r++) {
        var o = n[r];
        R(e, o, t[o]);
      }
    }(e, ge, _e), this.observeArray(e)) : this.walk(e);
  };

  function Ce(e, t) {
    var n;
    if (o(e) && !(e instanceof pe)) return y(e, "__ob__") && e.__ob__ instanceof we ? n = e.__ob__ : be && !te() && (Array.isArray(e) || s(e)) && Object.isExtensible(e) && !e._isVue && (n = new we(e)), t && n && n.vmCount++, n;
  }

  function xe(e, t, n, r, i) {
    var o = new ce(),
        a = Object.getOwnPropertyDescriptor(e, t);

    if (!a || !1 !== a.configurable) {
      var s = a && a.get,
          c = a && a.set;
      s && !c || 2 !== arguments.length || (n = e[t]);
      var u = !i && Ce(n);
      Object.defineProperty(e, t, {
        enumerable: !0,
        configurable: !0,
        get: function () {
          var t = s ? s.call(e) : n;
          return ce.target && (o.depend(), u && (u.dep.depend(), Array.isArray(t) && function e(t) {
            for (var n = void 0, r = 0, i = t.length; r < i; r++) (n = t[r]) && n.__ob__ && n.__ob__.dep.depend(), Array.isArray(n) && e(n);
          }(t))), t;
        },
        set: function (t) {
          var r = s ? s.call(e) : n;
          t === r || t != t && r != r || s && !c || (c ? c.call(e, t) : n = t, u = !i && Ce(t), o.notify());
        }
      });
    }
  }

  function ke(e, t, n) {
    if (Array.isArray(e) && c(t)) return e.length = Math.max(e.length, t), e.splice(t, 1, n), n;
    if (t in e && !(t in Object.prototype)) return e[t] = n, n;
    var r = e.__ob__;
    return e._isVue || r && r.vmCount ? n : r ? (xe(r.value, t, n), r.dep.notify(), n) : (e[t] = n, n);
  }

  function Ae(e, t) {
    if (Array.isArray(e) && c(t)) e.splice(t, 1);else {
      var n = e.__ob__;
      e._isVue || n && n.vmCount || y(e, t) && (delete e[t], n && n.dep.notify());
    }
  }

  we.prototype.walk = function (e) {
    for (var t = Object.keys(e), n = 0; n < t.length; n++) xe(e, t[n]);
  }, we.prototype.observeArray = function (e) {
    for (var t = 0, n = e.length; t < n; t++) Ce(e[t]);
  };
  var Oe = F.optionMergeStrategies;

  function Se(e, t) {
    if (!t) return e;

    for (var n, r, i, o = oe ? Reflect.ownKeys(t) : Object.keys(t), a = 0; a < o.length; a++) "__ob__" !== (n = o[a]) && (r = e[n], i = t[n], y(e, n) ? r !== i && s(r) && s(i) && Se(r, i) : ke(e, n, i));

    return e;
  }

  function Te(e, t, n) {
    return n ? function () {
      var r = "function" == typeof t ? t.call(n, n) : t,
          i = "function" == typeof e ? e.call(n, n) : e;
      return r ? Se(r, i) : i;
    } : t ? e ? function () {
      return Se("function" == typeof t ? t.call(this, this) : t, "function" == typeof e ? e.call(this, this) : e);
    } : t : e;
  }

  function Ee(e, t) {
    var n = t ? e ? e.concat(t) : Array.isArray(t) ? t : [t] : e;
    return n ? function (e) {
      for (var t = [], n = 0; n < e.length; n++) -1 === t.indexOf(e[n]) && t.push(e[n]);

      return t;
    }(n) : n;
  }

  function Ne(e, t, n, r) {
    var i = Object.create(e || null);
    return t ? A(i, t) : i;
  }

  Oe.data = function (e, t, n) {
    return n ? Te(e, t, n) : t && "function" != typeof t ? e : Te(e, t);
  }, I.forEach(function (e) {
    Oe[e] = Ee;
  }), M.forEach(function (e) {
    Oe[e + "s"] = Ne;
  }), Oe.watch = function (e, t, n, r) {
    if (e === Y && (e = void 0), t === Y && (t = void 0), !t) return Object.create(e || null);
    if (!e) return t;
    var i = {};

    for (var o in A(i, e), t) {
      var a = i[o],
          s = t[o];
      a && !Array.isArray(a) && (a = [a]), i[o] = a ? a.concat(s) : Array.isArray(s) ? s : [s];
    }

    return i;
  }, Oe.props = Oe.methods = Oe.inject = Oe.computed = function (e, t, n, r) {
    if (!e) return t;
    var i = Object.create(null);
    return A(i, e), t && A(i, t), i;
  }, Oe.provide = Te;

  var je = function (e, t) {
    return void 0 === t ? e : t;
  };

  function De(e, t, n) {
    if ("function" == typeof t && (t = t.options), function (e, t) {
      var n = e.props;

      if (n) {
        var r,
            i,
            o = {};
        if (Array.isArray(n)) for (r = n.length; r--;) "string" == typeof (i = n[r]) && (o[b(i)] = {
          type: null
        });else if (s(n)) for (var a in n) i = n[a], o[b(a)] = s(i) ? i : {
          type: i
        };
        e.props = o;
      }
    }(t), function (e, t) {
      var n = e.inject;

      if (n) {
        var r = e.inject = {};
        if (Array.isArray(n)) for (var i = 0; i < n.length; i++) r[n[i]] = {
          from: n[i]
        };else if (s(n)) for (var o in n) {
          var a = n[o];
          r[o] = s(a) ? A({
            from: o
          }, a) : {
            from: a
          };
        }
      }
    }(t), function (e) {
      var t = e.directives;
      if (t) for (var n in t) {
        var r = t[n];
        "function" == typeof r && (t[n] = {
          bind: r,
          update: r
        });
      }
    }(t), !t._base && (t.extends && (e = De(e, t.extends, n)), t.mixins)) for (var r = 0, i = t.mixins.length; r < i; r++) e = De(e, t.mixins[r], n);
    var o,
        a = {};

    for (o in e) c(o);

    for (o in t) y(e, o) || c(o);

    function c(r) {
      var i = Oe[r] || je;
      a[r] = i(e[r], t[r], n, r);
    }

    return a;
  }

  function Le(e, t, n, r) {
    if ("string" == typeof n) {
      var i = e[t];
      if (y(i, n)) return i[n];
      var o = b(n);
      if (y(i, o)) return i[o];
      var a = $(o);
      return y(i, a) ? i[a] : i[n] || i[o] || i[a];
    }
  }

  function Me(e, t, n, r) {
    var i = t[e],
        o = !y(n, e),
        a = n[e],
        s = Pe(Boolean, i.type);
    if (s > -1) if (o && !y(i, "default")) a = !1;else if ("" === a || a === C(e)) {
      var c = Pe(String, i.type);
      (c < 0 || s < c) && (a = !0);
    }

    if (void 0 === a) {
      a = function (e, t, n) {
        if (!y(t, "default")) return;
        var r = t.default;
        if (e && e.$options.propsData && void 0 === e.$options.propsData[n] && void 0 !== e._props[n]) return e._props[n];
        return "function" == typeof r && "Function" !== Ie(t.type) ? r.call(e) : r;
      }(r, i, e);

      var u = be;
      $e(!0), Ce(a), $e(u);
    }

    return a;
  }

  function Ie(e) {
    var t = e && e.toString().match(/^\s*function (\w+)/);
    return t ? t[1] : "";
  }

  function Fe(e, t) {
    return Ie(e) === Ie(t);
  }

  function Pe(e, t) {
    if (!Array.isArray(t)) return Fe(t, e) ? 0 : -1;

    for (var n = 0, r = t.length; n < r; n++) if (Fe(t[n], e)) return n;

    return -1;
  }

  function Re(e, t, n) {
    le();

    try {
      if (t) for (var r = t; r = r.$parent;) {
        var i = r.$options.errorCaptured;
        if (i) for (var o = 0; o < i.length; o++) try {
          if (!1 === i[o].call(r, e, t, n)) return;
        } catch (e) {
          Be(e, r, "errorCaptured hook");
        }
      }
      Be(e, t, n);
    } finally {
      fe();
    }
  }

  function He(e, t, n, r, i) {
    var o;

    try {
      (o = n ? e.apply(t, n) : e.call(t)) && !o._isVue && u(o) && !o._handled && (o.catch(function (e) {
        return Re(e, r, i + " (Promise/async)");
      }), o._handled = !0);
    } catch (e) {
      Re(e, r, i);
    }

    return o;
  }

  function Be(e, t, n) {
    if (F.errorHandler) try {
      return F.errorHandler.call(null, e, t, n);
    } catch (t) {
      t !== e && Ue(t, null, "config.errorHandler");
    }
    Ue(e, t, n);
  }

  function Ue(e, t, n) {
    if (!z && !V || "undefined" == typeof console) throw e;
    console.error(e);
  }

  var ze,
      Ve = !1,
      Ke = [],
      Je = !1;

  function qe() {
    Je = !1;
    var e = Ke.slice(0);
    Ke.length = 0;

    for (var t = 0; t < e.length; t++) e[t]();
  }

  if ("undefined" != typeof Promise && re(Promise)) {
    var We = Promise.resolve();
    ze = function () {
      We.then(qe), G && setTimeout(S);
    }, Ve = !0;
  } else if (q || "undefined" == typeof MutationObserver || !re(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString()) ze = "undefined" != typeof setImmediate && re(setImmediate) ? function () {
    setImmediate(qe);
  } : function () {
    setTimeout(qe, 0);
  };else {
    var Ze = 1,
        Ge = new MutationObserver(qe),
        Xe = document.createTextNode(String(Ze));
    Ge.observe(Xe, {
      characterData: !0
    }), ze = function () {
      Ze = (Ze + 1) % 2, Xe.data = String(Ze);
    }, Ve = !0;
  }

  function Ye(e, t) {
    var n;
    if (Ke.push(function () {
      if (e) try {
        e.call(t);
      } catch (e) {
        Re(e, t, "nextTick");
      } else n && n(t);
    }), Je || (Je = !0, ze()), !e && "undefined" != typeof Promise) return new Promise(function (e) {
      n = e;
    });
  }

  var Qe = new ie();

  function et(e) {
    !function e(t, n) {
      var r, i;
      var a = Array.isArray(t);
      if (!a && !o(t) || Object.isFrozen(t) || t instanceof pe) return;

      if (t.__ob__) {
        var s = t.__ob__.dep.id;
        if (n.has(s)) return;
        n.add(s);
      }

      if (a) for (r = t.length; r--;) e(t[r], n);else for (i = Object.keys(t), r = i.length; r--;) e(t[i[r]], n);
    }(e, Qe), Qe.clear();
  }

  var tt = g(function (e) {
    var t = "&" === e.charAt(0),
        n = "~" === (e = t ? e.slice(1) : e).charAt(0),
        r = "!" === (e = n ? e.slice(1) : e).charAt(0);
    return {
      name: e = r ? e.slice(1) : e,
      once: n,
      capture: r,
      passive: t
    };
  });

  function nt(e, t) {
    function n() {
      var e = arguments,
          r = n.fns;
      if (!Array.isArray(r)) return He(r, null, arguments, t, "v-on handler");

      for (var i = r.slice(), o = 0; o < i.length; o++) He(i[o], null, e, t, "v-on handler");
    }

    return n.fns = e, n;
  }

  function rt(e, n, i, o, a, s) {
    var c, u, l, f;

    for (c in e) u = e[c], l = n[c], f = tt(c), t(u) || (t(l) ? (t(u.fns) && (u = e[c] = nt(u, s)), r(f.once) && (u = e[c] = a(f.name, u, f.capture)), i(f.name, u, f.capture, f.passive, f.params)) : u !== l && (l.fns = u, e[c] = l));

    for (c in n) t(e[c]) && o((f = tt(c)).name, n[c], f.capture);
  }

  function it(e, i, o) {
    var a;
    e instanceof pe && (e = e.data.hook || (e.data.hook = {}));
    var s = e[i];

    function c() {
      o.apply(this, arguments), h(a.fns, c);
    }

    t(s) ? a = nt([c]) : n(s.fns) && r(s.merged) ? (a = s).fns.push(c) : a = nt([s, c]), a.merged = !0, e[i] = a;
  }

  function ot(e, t, r, i, o) {
    if (n(t)) {
      if (y(t, r)) return e[r] = t[r], o || delete t[r], !0;
      if (y(t, i)) return e[r] = t[i], o || delete t[i], !0;
    }

    return !1;
  }

  function at(e) {
    return i(e) ? [he(e)] : Array.isArray(e) ? function e(o, a) {
      var s = [];
      var c, u, l, f;

      for (c = 0; c < o.length; c++) t(u = o[c]) || "boolean" == typeof u || (l = s.length - 1, f = s[l], Array.isArray(u) ? u.length > 0 && (st((u = e(u, (a || "") + "_" + c))[0]) && st(f) && (s[l] = he(f.text + u[0].text), u.shift()), s.push.apply(s, u)) : i(u) ? st(f) ? s[l] = he(f.text + u) : "" !== u && s.push(he(u)) : st(u) && st(f) ? s[l] = he(f.text + u.text) : (r(o._isVList) && n(u.tag) && t(u.key) && n(a) && (u.key = "__vlist" + a + "_" + c + "__"), s.push(u)));

      return s;
    }(e) : void 0;
  }

  function st(e) {
    return n(e) && n(e.text) && !1 === e.isComment;
  }

  function ct(e, t) {
    if (e) {
      for (var n = Object.create(null), r = oe ? Reflect.ownKeys(e) : Object.keys(e), i = 0; i < r.length; i++) {
        var o = r[i];

        if ("__ob__" !== o) {
          for (var a = e[o].from, s = t; s;) {
            if (s._provided && y(s._provided, a)) {
              n[o] = s._provided[a];
              break;
            }

            s = s.$parent;
          }

          if (!s && "default" in e[o]) {
            var c = e[o].default;
            n[o] = "function" == typeof c ? c.call(t) : c;
          }
        }
      }

      return n;
    }
  }

  function ut(e, t) {
    if (!e || !e.length) return {};

    for (var n = {}, r = 0, i = e.length; r < i; r++) {
      var o = e[r],
          a = o.data;
      if (a && a.attrs && a.attrs.slot && delete a.attrs.slot, o.context !== t && o.fnContext !== t || !a || null == a.slot) (n.default || (n.default = [])).push(o);else {
        var s = a.slot,
            c = n[s] || (n[s] = []);
        "template" === o.tag ? c.push.apply(c, o.children || []) : c.push(o);
      }
    }

    for (var u in n) n[u].every(lt) && delete n[u];

    return n;
  }

  function lt(e) {
    return e.isComment && !e.asyncFactory || " " === e.text;
  }

  function ft(t, n, r) {
    var i,
        o = Object.keys(n).length > 0,
        a = t ? !!t.$stable : !o,
        s = t && t.$key;

    if (t) {
      if (t._normalized) return t._normalized;
      if (a && r && r !== e && s === r.$key && !o && !r.$hasNormal) return r;

      for (var c in i = {}, t) t[c] && "$" !== c[0] && (i[c] = pt(n, c, t[c]));
    } else i = {};

    for (var u in n) u in i || (i[u] = dt(n, u));

    return t && Object.isExtensible(t) && (t._normalized = i), R(i, "$stable", a), R(i, "$key", s), R(i, "$hasNormal", o), i;
  }

  function pt(e, t, n) {
    var r = function () {
      var e = arguments.length ? n.apply(null, arguments) : n({});
      return (e = e && "object" == typeof e && !Array.isArray(e) ? [e] : at(e)) && (0 === e.length || 1 === e.length && e[0].isComment) ? void 0 : e;
    };

    return n.proxy && Object.defineProperty(e, t, {
      get: r,
      enumerable: !0,
      configurable: !0
    }), r;
  }

  function dt(e, t) {
    return function () {
      return e[t];
    };
  }

  function vt(e, t) {
    var r, i, a, s, c;
    if (Array.isArray(e) || "string" == typeof e) for (r = new Array(e.length), i = 0, a = e.length; i < a; i++) r[i] = t(e[i], i);else if ("number" == typeof e) for (r = new Array(e), i = 0; i < e; i++) r[i] = t(i + 1, i);else if (o(e)) if (oe && e[Symbol.iterator]) {
      r = [];

      for (var u = e[Symbol.iterator](), l = u.next(); !l.done;) r.push(t(l.value, r.length)), l = u.next();
    } else for (s = Object.keys(e), r = new Array(s.length), i = 0, a = s.length; i < a; i++) c = s[i], r[i] = t(e[c], c, i);
    return n(r) || (r = []), r._isVList = !0, r;
  }

  function ht(e, t, n, r) {
    var i,
        o = this.$scopedSlots[e];
    o ? (n = n || {}, r && (n = A(A({}, r), n)), i = o(n) || t) : i = this.$slots[e] || t;
    var a = n && n.slot;
    return a ? this.$createElement("template", {
      slot: a
    }, i) : i;
  }

  function mt(e) {
    return Le(this.$options, "filters", e) || E;
  }

  function yt(e, t) {
    return Array.isArray(e) ? -1 === e.indexOf(t) : e !== t;
  }

  function gt(e, t, n, r, i) {
    var o = F.keyCodes[t] || n;
    return i && r && !F.keyCodes[t] ? yt(i, r) : o ? yt(o, e) : r ? C(r) !== t : void 0;
  }

  function _t(e, t, n, r, i) {
    if (n) if (o(n)) {
      var a;
      Array.isArray(n) && (n = O(n));

      var s = function (o) {
        if ("class" === o || "style" === o || v(o)) a = e;else {
          var s = e.attrs && e.attrs.type;
          a = r || F.mustUseProp(t, s, o) ? e.domProps || (e.domProps = {}) : e.attrs || (e.attrs = {});
        }
        var c = b(o),
            u = C(o);
        c in a || u in a || (a[o] = n[o], i && ((e.on || (e.on = {}))["update:" + o] = function (e) {
          n[o] = e;
        }));
      };

      for (var c in n) s(c);
    } else ;
    return e;
  }

  function bt(e, t) {
    var n = this._staticTrees || (this._staticTrees = []),
        r = n[e];
    return r && !t ? r : (wt(r = n[e] = this.$options.staticRenderFns[e].call(this._renderProxy, null, this), "__static__" + e, !1), r);
  }

  function $t(e, t, n) {
    return wt(e, "__once__" + t + (n ? "_" + n : ""), !0), e;
  }

  function wt(e, t, n) {
    if (Array.isArray(e)) for (var r = 0; r < e.length; r++) e[r] && "string" != typeof e[r] && Ct(e[r], t + "_" + r, n);else Ct(e, t, n);
  }

  function Ct(e, t, n) {
    e.isStatic = !0, e.key = t, e.isOnce = n;
  }

  function xt(e, t) {
    if (t) if (s(t)) {
      var n = e.on = e.on ? A({}, e.on) : {};

      for (var r in t) {
        var i = n[r],
            o = t[r];
        n[r] = i ? [].concat(i, o) : o;
      }
    } else ;
    return e;
  }

  function kt(e, t, n, r) {
    t = t || {
      $stable: !n
    };

    for (var i = 0; i < e.length; i++) {
      var o = e[i];
      Array.isArray(o) ? kt(o, t, n) : o && (o.proxy && (o.fn.proxy = !0), t[o.key] = o.fn);
    }

    return r && (t.$key = r), t;
  }

  function At(e, t) {
    for (var n = 0; n < t.length; n += 2) {
      var r = t[n];
      "string" == typeof r && r && (e[t[n]] = t[n + 1]);
    }

    return e;
  }

  function Ot(e, t) {
    return "string" == typeof e ? t + e : e;
  }

  function St(e) {
    e._o = $t, e._n = f, e._s = l, e._l = vt, e._t = ht, e._q = N, e._i = j, e._m = bt, e._f = mt, e._k = gt, e._b = _t, e._v = he, e._e = ve, e._u = kt, e._g = xt, e._d = At, e._p = Ot;
  }

  function Tt(t, n, i, o, a) {
    var s,
        c = this,
        u = a.options;
    y(o, "_uid") ? (s = Object.create(o))._original = o : (s = o, o = o._original);
    var l = r(u._compiled),
        f = !l;
    this.data = t, this.props = n, this.children = i, this.parent = o, this.listeners = t.on || e, this.injections = ct(u.inject, o), this.slots = function () {
      return c.$slots || ft(t.scopedSlots, c.$slots = ut(i, o)), c.$slots;
    }, Object.defineProperty(this, "scopedSlots", {
      enumerable: !0,
      get: function () {
        return ft(t.scopedSlots, this.slots());
      }
    }), l && (this.$options = u, this.$slots = this.slots(), this.$scopedSlots = ft(t.scopedSlots, this.$slots)), u._scopeId ? this._c = function (e, t, n, r) {
      var i = Pt(s, e, t, n, r, f);
      return i && !Array.isArray(i) && (i.fnScopeId = u._scopeId, i.fnContext = o), i;
    } : this._c = function (e, t, n, r) {
      return Pt(s, e, t, n, r, f);
    };
  }

  function Et(e, t, n, r, i) {
    var o = me(e);
    return o.fnContext = n, o.fnOptions = r, t.slot && ((o.data || (o.data = {})).slot = t.slot), o;
  }

  function Nt(e, t) {
    for (var n in t) e[b(n)] = t[n];
  }

  St(Tt.prototype);
  var jt = {
    init: function (e, t) {
      if (e.componentInstance && !e.componentInstance._isDestroyed && e.data.keepAlive) {
        var r = e;
        jt.prepatch(r, r);
      } else {
        (e.componentInstance = function (e, t) {
          var r = {
            _isComponent: !0,
            _parentVnode: e,
            parent: t
          },
              i = e.data.inlineTemplate;
          n(i) && (r.render = i.render, r.staticRenderFns = i.staticRenderFns);
          return new e.componentOptions.Ctor(r);
        }(e, Wt)).$mount(t ? e.elm : void 0, t);
      }
    },
    prepatch: function (t, n) {
      var r = n.componentOptions;
      !function (t, n, r, i, o) {
        var a = i.data.scopedSlots,
            s = t.$scopedSlots,
            c = !!(a && !a.$stable || s !== e && !s.$stable || a && t.$scopedSlots.$key !== a.$key),
            u = !!(o || t.$options._renderChildren || c);
        t.$options._parentVnode = i, t.$vnode = i, t._vnode && (t._vnode.parent = i);

        if (t.$options._renderChildren = o, t.$attrs = i.data.attrs || e, t.$listeners = r || e, n && t.$options.props) {
          $e(!1);

          for (var l = t._props, f = t.$options._propKeys || [], p = 0; p < f.length; p++) {
            var d = f[p],
                v = t.$options.props;
            l[d] = Me(d, v, n, t);
          }

          $e(!0), t.$options.propsData = n;
        }

        r = r || e;
        var h = t.$options._parentListeners;
        t.$options._parentListeners = r, qt(t, r, h), u && (t.$slots = ut(o, i.context), t.$forceUpdate());
      }(n.componentInstance = t.componentInstance, r.propsData, r.listeners, n, r.children);
    },
    insert: function (e) {
      var t,
          n = e.context,
          r = e.componentInstance;
      r._isMounted || (r._isMounted = !0, Yt(r, "mounted")), e.data.keepAlive && (n._isMounted ? ((t = r)._inactive = !1, en.push(t)) : Xt(r, !0));
    },
    destroy: function (e) {
      var t = e.componentInstance;
      t._isDestroyed || (e.data.keepAlive ? function e(t, n) {
        if (n && (t._directInactive = !0, Gt(t))) return;

        if (!t._inactive) {
          t._inactive = !0;

          for (var r = 0; r < t.$children.length; r++) e(t.$children[r]);

          Yt(t, "deactivated");
        }
      }(t, !0) : t.$destroy());
    }
  },
      Dt = Object.keys(jt);

  function Lt(i, a, s, c, l) {
    if (!t(i)) {
      var f = s.$options._base;

      if (o(i) && (i = f.extend(i)), "function" == typeof i) {
        var p;
        if (t(i.cid) && void 0 === (i = function (e, i) {
          if (r(e.error) && n(e.errorComp)) return e.errorComp;
          if (n(e.resolved)) return e.resolved;
          var a = Ht;
          a && n(e.owners) && -1 === e.owners.indexOf(a) && e.owners.push(a);
          if (r(e.loading) && n(e.loadingComp)) return e.loadingComp;

          if (a && !n(e.owners)) {
            var s = e.owners = [a],
                c = !0,
                l = null,
                f = null;
            a.$on("hook:destroyed", function () {
              return h(s, a);
            });

            var p = function (e) {
              for (var t = 0, n = s.length; t < n; t++) s[t].$forceUpdate();

              e && (s.length = 0, null !== l && (clearTimeout(l), l = null), null !== f && (clearTimeout(f), f = null));
            },
                d = D(function (t) {
              e.resolved = Bt(t, i), c ? s.length = 0 : p(!0);
            }),
                v = D(function (t) {
              n(e.errorComp) && (e.error = !0, p(!0));
            }),
                m = e(d, v);

            return o(m) && (u(m) ? t(e.resolved) && m.then(d, v) : u(m.component) && (m.component.then(d, v), n(m.error) && (e.errorComp = Bt(m.error, i)), n(m.loading) && (e.loadingComp = Bt(m.loading, i), 0 === m.delay ? e.loading = !0 : l = setTimeout(function () {
              l = null, t(e.resolved) && t(e.error) && (e.loading = !0, p(!1));
            }, m.delay || 200)), n(m.timeout) && (f = setTimeout(function () {
              f = null, t(e.resolved) && v(null);
            }, m.timeout)))), c = !1, e.loading ? e.loadingComp : e.resolved;
          }
        }(p = i, f))) return function (e, t, n, r, i) {
          var o = ve();
          return o.asyncFactory = e, o.asyncMeta = {
            data: t,
            context: n,
            children: r,
            tag: i
          }, o;
        }(p, a, s, c, l);
        a = a || {}, $n(i), n(a.model) && function (e, t) {
          var r = e.model && e.model.prop || "value",
              i = e.model && e.model.event || "input";
          (t.attrs || (t.attrs = {}))[r] = t.model.value;
          var o = t.on || (t.on = {}),
              a = o[i],
              s = t.model.callback;
          n(a) ? (Array.isArray(a) ? -1 === a.indexOf(s) : a !== s) && (o[i] = [s].concat(a)) : o[i] = s;
        }(i.options, a);

        var d = function (e, r, i) {
          var o = r.options.props;

          if (!t(o)) {
            var a = {},
                s = e.attrs,
                c = e.props;
            if (n(s) || n(c)) for (var u in o) {
              var l = C(u);
              ot(a, c, u, l, !0) || ot(a, s, u, l, !1);
            }
            return a;
          }
        }(a, i);

        if (r(i.options.functional)) return function (t, r, i, o, a) {
          var s = t.options,
              c = {},
              u = s.props;
          if (n(u)) for (var l in u) c[l] = Me(l, u, r || e);else n(i.attrs) && Nt(c, i.attrs), n(i.props) && Nt(c, i.props);
          var f = new Tt(i, c, a, o, t),
              p = s.render.call(null, f._c, f);
          if (p instanceof pe) return Et(p, i, f.parent, s);

          if (Array.isArray(p)) {
            for (var d = at(p) || [], v = new Array(d.length), h = 0; h < d.length; h++) v[h] = Et(d[h], i, f.parent, s);

            return v;
          }
        }(i, d, a, s, c);
        var v = a.on;

        if (a.on = a.nativeOn, r(i.options.abstract)) {
          var m = a.slot;
          a = {}, m && (a.slot = m);
        }

        !function (e) {
          for (var t = e.hook || (e.hook = {}), n = 0; n < Dt.length; n++) {
            var r = Dt[n],
                i = t[r],
                o = jt[r];
            i === o || i && i._merged || (t[r] = i ? Mt(o, i) : o);
          }
        }(a);
        var y = i.options.name || l;
        return new pe("vue-component-" + i.cid + (y ? "-" + y : ""), a, void 0, void 0, void 0, s, {
          Ctor: i,
          propsData: d,
          listeners: v,
          tag: l,
          children: c
        }, p);
      }
    }
  }

  function Mt(e, t) {
    var n = function (n, r) {
      e(n, r), t(n, r);
    };

    return n._merged = !0, n;
  }

  var It = 1,
      Ft = 2;

  function Pt(e, a, s, c, u, l) {
    return (Array.isArray(s) || i(s)) && (u = c, c = s, s = void 0), r(l) && (u = Ft), function (e, i, a, s, c) {
      if (n(a) && n(a.__ob__)) return ve();
      n(a) && n(a.is) && (i = a.is);
      if (!i) return ve();
      Array.isArray(s) && "function" == typeof s[0] && ((a = a || {}).scopedSlots = {
        default: s[0]
      }, s.length = 0);
      c === Ft ? s = at(s) : c === It && (s = function (e) {
        for (var t = 0; t < e.length; t++) if (Array.isArray(e[t])) return Array.prototype.concat.apply([], e);

        return e;
      }(s));
      var u, l;

      if ("string" == typeof i) {
        var f;
        l = e.$vnode && e.$vnode.ns || F.getTagNamespace(i), u = F.isReservedTag(i) ? new pe(F.parsePlatformTagName(i), a, s, void 0, void 0, e) : a && a.pre || !n(f = Le(e.$options, "components", i)) ? new pe(i, a, s, void 0, void 0, e) : Lt(f, a, e, s, i);
      } else u = Lt(i, a, e, s);

      return Array.isArray(u) ? u : n(u) ? (n(l) && function e(i, o, a) {
        i.ns = o;
        "foreignObject" === i.tag && (o = void 0, a = !0);
        if (n(i.children)) for (var s = 0, c = i.children.length; s < c; s++) {
          var u = i.children[s];
          n(u.tag) && (t(u.ns) || r(a) && "svg" !== u.tag) && e(u, o, a);
        }
      }(u, l), n(a) && function (e) {
        o(e.style) && et(e.style);
        o(e.class) && et(e.class);
      }(a), u) : ve();
    }(e, a, s, c, u);
  }

  var Rt,
      Ht = null;

  function Bt(e, t) {
    return (e.__esModule || oe && "Module" === e[Symbol.toStringTag]) && (e = e.default), o(e) ? t.extend(e) : e;
  }

  function Ut(e) {
    return e.isComment && e.asyncFactory;
  }

  function zt(e) {
    if (Array.isArray(e)) for (var t = 0; t < e.length; t++) {
      var r = e[t];
      if (n(r) && (n(r.componentOptions) || Ut(r))) return r;
    }
  }

  function Vt(e, t) {
    Rt.$on(e, t);
  }

  function Kt(e, t) {
    Rt.$off(e, t);
  }

  function Jt(e, t) {
    var n = Rt;
    return function r() {
      null !== t.apply(null, arguments) && n.$off(e, r);
    };
  }

  function qt(e, t, n) {
    Rt = e, rt(t, n || {}, Vt, Kt, Jt, e), Rt = void 0;
  }

  var Wt = null;

  function Zt(e) {
    var t = Wt;
    return Wt = e, function () {
      Wt = t;
    };
  }

  function Gt(e) {
    for (; e && (e = e.$parent);) if (e._inactive) return !0;

    return !1;
  }

  function Xt(e, t) {
    if (t) {
      if (e._directInactive = !1, Gt(e)) return;
    } else if (e._directInactive) return;

    if (e._inactive || null === e._inactive) {
      e._inactive = !1;

      for (var n = 0; n < e.$children.length; n++) Xt(e.$children[n]);

      Yt(e, "activated");
    }
  }

  function Yt(e, t) {
    le();
    var n = e.$options[t],
        r = t + " hook";
    if (n) for (var i = 0, o = n.length; i < o; i++) He(n[i], e, null, e, r);
    e._hasHookEvent && e.$emit("hook:" + t), fe();
  }

  var Qt = [],
      en = [],
      tn = {},
      nn = !1,
      rn = !1,
      on = 0;
  var an = 0,
      sn = Date.now;

  if (z && !q) {
    var cn = window.performance;
    cn && "function" == typeof cn.now && sn() > document.createEvent("Event").timeStamp && (sn = function () {
      return cn.now();
    });
  }

  function un() {
    var e, t;

    for (an = sn(), rn = !0, Qt.sort(function (e, t) {
      return e.id - t.id;
    }), on = 0; on < Qt.length; on++) (e = Qt[on]).before && e.before(), t = e.id, tn[t] = null, e.run();

    var n = en.slice(),
        r = Qt.slice();
    on = Qt.length = en.length = 0, tn = {}, nn = rn = !1, function (e) {
      for (var t = 0; t < e.length; t++) e[t]._inactive = !0, Xt(e[t], !0);
    }(n), function (e) {
      var t = e.length;

      for (; t--;) {
        var n = e[t],
            r = n.vm;
        r._watcher === n && r._isMounted && !r._isDestroyed && Yt(r, "updated");
      }
    }(r), ne && F.devtools && ne.emit("flush");
  }

  var ln = 0,
      fn = function (e, t, n, r, i) {
    this.vm = e, i && (e._watcher = this), e._watchers.push(this), r ? (this.deep = !!r.deep, this.user = !!r.user, this.lazy = !!r.lazy, this.sync = !!r.sync, this.before = r.before) : this.deep = this.user = this.lazy = this.sync = !1, this.cb = n, this.id = ++ln, this.active = !0, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new ie(), this.newDepIds = new ie(), this.expression = "", "function" == typeof t ? this.getter = t : (this.getter = function (e) {
      if (!H.test(e)) {
        var t = e.split(".");
        return function (e) {
          for (var n = 0; n < t.length; n++) {
            if (!e) return;
            e = e[t[n]];
          }

          return e;
        };
      }
    }(t), this.getter || (this.getter = S)), this.value = this.lazy ? void 0 : this.get();
  };

  fn.prototype.get = function () {
    var e;
    le(this);
    var t = this.vm;

    try {
      e = this.getter.call(t, t);
    } catch (e) {
      if (!this.user) throw e;
      Re(e, t, 'getter for watcher "' + this.expression + '"');
    } finally {
      this.deep && et(e), fe(), this.cleanupDeps();
    }

    return e;
  }, fn.prototype.addDep = function (e) {
    var t = e.id;
    this.newDepIds.has(t) || (this.newDepIds.add(t), this.newDeps.push(e), this.depIds.has(t) || e.addSub(this));
  }, fn.prototype.cleanupDeps = function () {
    for (var e = this.deps.length; e--;) {
      var t = this.deps[e];
      this.newDepIds.has(t.id) || t.removeSub(this);
    }

    var n = this.depIds;
    this.depIds = this.newDepIds, this.newDepIds = n, this.newDepIds.clear(), n = this.deps, this.deps = this.newDeps, this.newDeps = n, this.newDeps.length = 0;
  }, fn.prototype.update = function () {
    this.lazy ? this.dirty = !0 : this.sync ? this.run() : function (e) {
      var t = e.id;

      if (null == tn[t]) {
        if (tn[t] = !0, rn) {
          for (var n = Qt.length - 1; n > on && Qt[n].id > e.id;) n--;

          Qt.splice(n + 1, 0, e);
        } else Qt.push(e);

        nn || (nn = !0, Ye(un));
      }
    }(this);
  }, fn.prototype.run = function () {
    if (this.active) {
      var e = this.get();

      if (e !== this.value || o(e) || this.deep) {
        var t = this.value;
        if (this.value = e, this.user) try {
          this.cb.call(this.vm, e, t);
        } catch (e) {
          Re(e, this.vm, 'callback for watcher "' + this.expression + '"');
        } else this.cb.call(this.vm, e, t);
      }
    }
  }, fn.prototype.evaluate = function () {
    this.value = this.get(), this.dirty = !1;
  }, fn.prototype.depend = function () {
    for (var e = this.deps.length; e--;) this.deps[e].depend();
  }, fn.prototype.teardown = function () {
    if (this.active) {
      this.vm._isBeingDestroyed || h(this.vm._watchers, this);

      for (var e = this.deps.length; e--;) this.deps[e].removeSub(this);

      this.active = !1;
    }
  };
  var pn = {
    enumerable: !0,
    configurable: !0,
    get: S,
    set: S
  };

  function dn(e, t, n) {
    pn.get = function () {
      return this[t][n];
    }, pn.set = function (e) {
      this[t][n] = e;
    }, Object.defineProperty(e, n, pn);
  }

  function vn(e) {
    e._watchers = [];
    var t = e.$options;
    t.props && function (e, t) {
      var n = e.$options.propsData || {},
          r = e._props = {},
          i = e.$options._propKeys = [];
      e.$parent && $e(!1);

      var o = function (o) {
        i.push(o);
        var a = Me(o, t, n, e);
        xe(r, o, a), o in e || dn(e, "_props", o);
      };

      for (var a in t) o(a);

      $e(!0);
    }(e, t.props), t.methods && function (e, t) {
      e.$options.props;

      for (var n in t) e[n] = "function" != typeof t[n] ? S : x(t[n], e);
    }(e, t.methods), t.data ? function (e) {
      var t = e.$options.data;
      s(t = e._data = "function" == typeof t ? function (e, t) {
        le();

        try {
          return e.call(t, t);
        } catch (e) {
          return Re(e, t, "data()"), {};
        } finally {
          fe();
        }
      }(t, e) : t || {}) || (t = {});
      var n = Object.keys(t),
          r = e.$options.props,
          i = (e.$options.methods, n.length);

      for (; i--;) {
        var o = n[i];
        r && y(r, o) || (a = void 0, 36 !== (a = (o + "").charCodeAt(0)) && 95 !== a && dn(e, "_data", o));
      }

      var a;
      Ce(t, !0);
    }(e) : Ce(e._data = {}, !0), t.computed && function (e, t) {
      var n = e._computedWatchers = Object.create(null),
          r = te();

      for (var i in t) {
        var o = t[i],
            a = "function" == typeof o ? o : o.get;
        r || (n[i] = new fn(e, a || S, S, hn)), i in e || mn(e, i, o);
      }
    }(e, t.computed), t.watch && t.watch !== Y && function (e, t) {
      for (var n in t) {
        var r = t[n];
        if (Array.isArray(r)) for (var i = 0; i < r.length; i++) _n(e, n, r[i]);else _n(e, n, r);
      }
    }(e, t.watch);
  }

  var hn = {
    lazy: !0
  };

  function mn(e, t, n) {
    var r = !te();
    "function" == typeof n ? (pn.get = r ? yn(t) : gn(n), pn.set = S) : (pn.get = n.get ? r && !1 !== n.cache ? yn(t) : gn(n.get) : S, pn.set = n.set || S), Object.defineProperty(e, t, pn);
  }

  function yn(e) {
    return function () {
      var t = this._computedWatchers && this._computedWatchers[e];
      if (t) return t.dirty && t.evaluate(), ce.target && t.depend(), t.value;
    };
  }

  function gn(e) {
    return function () {
      return e.call(this, this);
    };
  }

  function _n(e, t, n, r) {
    return s(n) && (r = n, n = n.handler), "string" == typeof n && (n = e[n]), e.$watch(t, n, r);
  }

  var bn = 0;

  function $n(e) {
    var t = e.options;

    if (e.super) {
      var n = $n(e.super);

      if (n !== e.superOptions) {
        e.superOptions = n;

        var r = function (e) {
          var t,
              n = e.options,
              r = e.sealedOptions;

          for (var i in n) n[i] !== r[i] && (t || (t = {}), t[i] = n[i]);

          return t;
        }(e);

        r && A(e.extendOptions, r), (t = e.options = De(n, e.extendOptions)).name && (t.components[t.name] = e);
      }
    }

    return t;
  }

  function wn(e) {
    this._init(e);
  }

  function Cn(e) {
    e.cid = 0;
    var t = 1;

    e.extend = function (e) {
      e = e || {};
      var n = this,
          r = n.cid,
          i = e._Ctor || (e._Ctor = {});
      if (i[r]) return i[r];

      var o = e.name || n.options.name,
          a = function (e) {
        this._init(e);
      };

      return (a.prototype = Object.create(n.prototype)).constructor = a, a.cid = t++, a.options = De(n.options, e), a.super = n, a.options.props && function (e) {
        var t = e.options.props;

        for (var n in t) dn(e.prototype, "_props", n);
      }(a), a.options.computed && function (e) {
        var t = e.options.computed;

        for (var n in t) mn(e.prototype, n, t[n]);
      }(a), a.extend = n.extend, a.mixin = n.mixin, a.use = n.use, M.forEach(function (e) {
        a[e] = n[e];
      }), o && (a.options.components[o] = a), a.superOptions = n.options, a.extendOptions = e, a.sealedOptions = A({}, a.options), i[r] = a, a;
    };
  }

  function xn(e) {
    return e && (e.Ctor.options.name || e.tag);
  }

  function kn(e, t) {
    return Array.isArray(e) ? e.indexOf(t) > -1 : "string" == typeof e ? e.split(",").indexOf(t) > -1 : (n = e, "[object RegExp]" === a.call(n) && e.test(t));
    var n;
  }

  function An(e, t) {
    var n = e.cache,
        r = e.keys,
        i = e._vnode;

    for (var o in n) {
      var a = n[o];

      if (a) {
        var s = xn(a.componentOptions);
        s && !t(s) && On(n, o, r, i);
      }
    }
  }

  function On(e, t, n, r) {
    var i = e[t];
    !i || r && i.tag === r.tag || i.componentInstance.$destroy(), e[t] = null, h(n, t);
  }

  !function (t) {
    t.prototype._init = function (t) {
      var n = this;
      n._uid = bn++, n._isVue = !0, t && t._isComponent ? function (e, t) {
        var n = e.$options = Object.create(e.constructor.options),
            r = t._parentVnode;
        n.parent = t.parent, n._parentVnode = r;
        var i = r.componentOptions;
        n.propsData = i.propsData, n._parentListeners = i.listeners, n._renderChildren = i.children, n._componentTag = i.tag, t.render && (n.render = t.render, n.staticRenderFns = t.staticRenderFns);
      }(n, t) : n.$options = De($n(n.constructor), t || {}, n), n._renderProxy = n, n._self = n, function (e) {
        var t = e.$options,
            n = t.parent;

        if (n && !t.abstract) {
          for (; n.$options.abstract && n.$parent;) n = n.$parent;

          n.$children.push(e);
        }

        e.$parent = n, e.$root = n ? n.$root : e, e.$children = [], e.$refs = {}, e._watcher = null, e._inactive = null, e._directInactive = !1, e._isMounted = !1, e._isDestroyed = !1, e._isBeingDestroyed = !1;
      }(n), function (e) {
        e._events = Object.create(null), e._hasHookEvent = !1;
        var t = e.$options._parentListeners;
        t && qt(e, t);
      }(n), function (t) {
        t._vnode = null, t._staticTrees = null;
        var n = t.$options,
            r = t.$vnode = n._parentVnode,
            i = r && r.context;
        t.$slots = ut(n._renderChildren, i), t.$scopedSlots = e, t._c = function (e, n, r, i) {
          return Pt(t, e, n, r, i, !1);
        }, t.$createElement = function (e, n, r, i) {
          return Pt(t, e, n, r, i, !0);
        };
        var o = r && r.data;
        xe(t, "$attrs", o && o.attrs || e, null, !0), xe(t, "$listeners", n._parentListeners || e, null, !0);
      }(n), Yt(n, "beforeCreate"), function (e) {
        var t = ct(e.$options.inject, e);
        t && ($e(!1), Object.keys(t).forEach(function (n) {
          xe(e, n, t[n]);
        }), $e(!0));
      }(n), vn(n), function (e) {
        var t = e.$options.provide;
        t && (e._provided = "function" == typeof t ? t.call(e) : t);
      }(n), Yt(n, "created"), n.$options.el && n.$mount(n.$options.el);
    };
  }(wn), function (e) {
    var t = {
      get: function () {
        return this._data;
      }
    },
        n = {
      get: function () {
        return this._props;
      }
    };
    Object.defineProperty(e.prototype, "$data", t), Object.defineProperty(e.prototype, "$props", n), e.prototype.$set = ke, e.prototype.$delete = Ae, e.prototype.$watch = function (e, t, n) {
      if (s(t)) return _n(this, e, t, n);
      (n = n || {}).user = !0;
      var r = new fn(this, e, t, n);
      if (n.immediate) try {
        t.call(this, r.value);
      } catch (e) {
        Re(e, this, 'callback for immediate watcher "' + r.expression + '"');
      }
      return function () {
        r.teardown();
      };
    };
  }(wn), function (e) {
    var t = /^hook:/;
    e.prototype.$on = function (e, n) {
      var r = this;
      if (Array.isArray(e)) for (var i = 0, o = e.length; i < o; i++) r.$on(e[i], n);else (r._events[e] || (r._events[e] = [])).push(n), t.test(e) && (r._hasHookEvent = !0);
      return r;
    }, e.prototype.$once = function (e, t) {
      var n = this;

      function r() {
        n.$off(e, r), t.apply(n, arguments);
      }

      return r.fn = t, n.$on(e, r), n;
    }, e.prototype.$off = function (e, t) {
      var n = this;
      if (!arguments.length) return n._events = Object.create(null), n;

      if (Array.isArray(e)) {
        for (var r = 0, i = e.length; r < i; r++) n.$off(e[r], t);

        return n;
      }

      var o,
          a = n._events[e];
      if (!a) return n;
      if (!t) return n._events[e] = null, n;

      for (var s = a.length; s--;) if ((o = a[s]) === t || o.fn === t) {
        a.splice(s, 1);
        break;
      }

      return n;
    }, e.prototype.$emit = function (e) {
      var t = this._events[e];

      if (t) {
        t = t.length > 1 ? k(t) : t;

        for (var n = k(arguments, 1), r = 'event handler for "' + e + '"', i = 0, o = t.length; i < o; i++) He(t[i], this, n, this, r);
      }

      return this;
    };
  }(wn), function (e) {
    e.prototype._update = function (e, t) {
      var n = this,
          r = n.$el,
          i = n._vnode,
          o = Zt(n);
      n._vnode = e, n.$el = i ? n.__patch__(i, e) : n.__patch__(n.$el, e, t, !1), o(), r && (r.__vue__ = null), n.$el && (n.$el.__vue__ = n), n.$vnode && n.$parent && n.$vnode === n.$parent._vnode && (n.$parent.$el = n.$el);
    }, e.prototype.$forceUpdate = function () {
      this._watcher && this._watcher.update();
    }, e.prototype.$destroy = function () {
      var e = this;

      if (!e._isBeingDestroyed) {
        Yt(e, "beforeDestroy"), e._isBeingDestroyed = !0;
        var t = e.$parent;
        !t || t._isBeingDestroyed || e.$options.abstract || h(t.$children, e), e._watcher && e._watcher.teardown();

        for (var n = e._watchers.length; n--;) e._watchers[n].teardown();

        e._data.__ob__ && e._data.__ob__.vmCount--, e._isDestroyed = !0, e.__patch__(e._vnode, null), Yt(e, "destroyed"), e.$off(), e.$el && (e.$el.__vue__ = null), e.$vnode && (e.$vnode.parent = null);
      }
    };
  }(wn), function (e) {
    St(e.prototype), e.prototype.$nextTick = function (e) {
      return Ye(e, this);
    }, e.prototype._render = function () {
      var e,
          t = this,
          n = t.$options,
          r = n.render,
          i = n._parentVnode;
      i && (t.$scopedSlots = ft(i.data.scopedSlots, t.$slots, t.$scopedSlots)), t.$vnode = i;

      try {
        Ht = t, e = r.call(t._renderProxy, t.$createElement);
      } catch (n) {
        Re(n, t, "render"), e = t._vnode;
      } finally {
        Ht = null;
      }

      return Array.isArray(e) && 1 === e.length && (e = e[0]), e instanceof pe || (e = ve()), e.parent = i, e;
    };
  }(wn);
  var Sn = [String, RegExp, Array],
      Tn = {
    KeepAlive: {
      name: "keep-alive",
      abstract: !0,
      props: {
        include: Sn,
        exclude: Sn,
        max: [String, Number]
      },
      created: function () {
        this.cache = Object.create(null), this.keys = [];
      },
      destroyed: function () {
        for (var e in this.cache) On(this.cache, e, this.keys);
      },
      mounted: function () {
        var e = this;
        this.$watch("include", function (t) {
          An(e, function (e) {
            return kn(t, e);
          });
        }), this.$watch("exclude", function (t) {
          An(e, function (e) {
            return !kn(t, e);
          });
        });
      },
      render: function () {
        var e = this.$slots.default,
            t = zt(e),
            n = t && t.componentOptions;

        if (n) {
          var r = xn(n),
              i = this.include,
              o = this.exclude;
          if (i && (!r || !kn(i, r)) || o && r && kn(o, r)) return t;
          var a = this.cache,
              s = this.keys,
              c = null == t.key ? n.Ctor.cid + (n.tag ? "::" + n.tag : "") : t.key;
          a[c] ? (t.componentInstance = a[c].componentInstance, h(s, c), s.push(c)) : (a[c] = t, s.push(c), this.max && s.length > parseInt(this.max) && On(a, s[0], s, this._vnode)), t.data.keepAlive = !0;
        }

        return t || e && e[0];
      }
    }
  };
  !function (e) {
    var t = {
      get: function () {
        return F;
      }
    };
    Object.defineProperty(e, "config", t), e.util = {
      warn: ae,
      extend: A,
      mergeOptions: De,
      defineReactive: xe
    }, e.set = ke, e.delete = Ae, e.nextTick = Ye, e.observable = function (e) {
      return Ce(e), e;
    }, e.options = Object.create(null), M.forEach(function (t) {
      e.options[t + "s"] = Object.create(null);
    }), e.options._base = e, A(e.options.components, Tn), function (e) {
      e.use = function (e) {
        var t = this._installedPlugins || (this._installedPlugins = []);
        if (t.indexOf(e) > -1) return this;
        var n = k(arguments, 1);
        return n.unshift(this), "function" == typeof e.install ? e.install.apply(e, n) : "function" == typeof e && e.apply(null, n), t.push(e), this;
      };
    }(e), function (e) {
      e.mixin = function (e) {
        return this.options = De(this.options, e), this;
      };
    }(e), Cn(e), function (e) {
      M.forEach(function (t) {
        e[t] = function (e, n) {
          return n ? ("component" === t && s(n) && (n.name = n.name || e, n = this.options._base.extend(n)), "directive" === t && "function" == typeof n && (n = {
            bind: n,
            update: n
          }), this.options[t + "s"][e] = n, n) : this.options[t + "s"][e];
        };
      });
    }(e);
  }(wn), Object.defineProperty(wn.prototype, "$isServer", {
    get: te
  }), Object.defineProperty(wn.prototype, "$ssrContext", {
    get: function () {
      return this.$vnode && this.$vnode.ssrContext;
    }
  }), Object.defineProperty(wn, "FunctionalRenderContext", {
    value: Tt
  }), wn.version = "2.6.12";

  var En = p("style,class"),
      Nn = p("input,textarea,option,select,progress"),
      jn = function (e, t, n) {
    return "value" === n && Nn(e) && "button" !== t || "selected" === n && "option" === e || "checked" === n && "input" === e || "muted" === n && "video" === e;
  },
      Dn = p("contenteditable,draggable,spellcheck"),
      Ln = p("events,caret,typing,plaintext-only"),
      Mn = function (e, t) {
    return Hn(t) || "false" === t ? "false" : "contenteditable" === e && Ln(t) ? t : "true";
  },
      In = p("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),
      Fn = "http://www.w3.org/1999/xlink",
      Pn = function (e) {
    return ":" === e.charAt(5) && "xlink" === e.slice(0, 5);
  },
      Rn = function (e) {
    return Pn(e) ? e.slice(6, e.length) : "";
  },
      Hn = function (e) {
    return null == e || !1 === e;
  };

  function Bn(e) {
    for (var t = e.data, r = e, i = e; n(i.componentInstance);) (i = i.componentInstance._vnode) && i.data && (t = Un(i.data, t));

    for (; n(r = r.parent);) r && r.data && (t = Un(t, r.data));

    return function (e, t) {
      if (n(e) || n(t)) return zn(e, Vn(t));
      return "";
    }(t.staticClass, t.class);
  }

  function Un(e, t) {
    return {
      staticClass: zn(e.staticClass, t.staticClass),
      class: n(e.class) ? [e.class, t.class] : t.class
    };
  }

  function zn(e, t) {
    return e ? t ? e + " " + t : e : t || "";
  }

  function Vn(e) {
    return Array.isArray(e) ? function (e) {
      for (var t, r = "", i = 0, o = e.length; i < o; i++) n(t = Vn(e[i])) && "" !== t && (r && (r += " "), r += t);

      return r;
    }(e) : o(e) ? function (e) {
      var t = "";

      for (var n in e) e[n] && (t && (t += " "), t += n);

      return t;
    }(e) : "string" == typeof e ? e : "";
  }

  var Kn = {
    svg: "http://www.w3.org/2000/svg",
    math: "http://www.w3.org/1998/Math/MathML"
  },
      Jn = p("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),
      qn = p("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", !0),
      Wn = function (e) {
    return Jn(e) || qn(e);
  };

  function Zn(e) {
    return qn(e) ? "svg" : "math" === e ? "math" : void 0;
  }

  var Gn = Object.create(null);
  var Xn = p("text,number,password,search,email,tel,url");

  function Yn(e) {
    if ("string" == typeof e) {
      var t = document.querySelector(e);
      return t || document.createElement("div");
    }

    return e;
  }

  var Qn = Object.freeze({
    createElement: function (e, t) {
      var n = document.createElement(e);
      return "select" !== e ? n : (t.data && t.data.attrs && void 0 !== t.data.attrs.multiple && n.setAttribute("multiple", "multiple"), n);
    },
    createElementNS: function (e, t) {
      return document.createElementNS(Kn[e], t);
    },
    createTextNode: function (e) {
      return document.createTextNode(e);
    },
    createComment: function (e) {
      return document.createComment(e);
    },
    insertBefore: function (e, t, n) {
      e.insertBefore(t, n);
    },
    removeChild: function (e, t) {
      e.removeChild(t);
    },
    appendChild: function (e, t) {
      e.appendChild(t);
    },
    parentNode: function (e) {
      return e.parentNode;
    },
    nextSibling: function (e) {
      return e.nextSibling;
    },
    tagName: function (e) {
      return e.tagName;
    },
    setTextContent: function (e, t) {
      e.textContent = t;
    },
    setStyleScope: function (e, t) {
      e.setAttribute(t, "");
    }
  }),
      er = {
    create: function (e, t) {
      tr(t);
    },
    update: function (e, t) {
      e.data.ref !== t.data.ref && (tr(e, !0), tr(t));
    },
    destroy: function (e) {
      tr(e, !0);
    }
  };

  function tr(e, t) {
    var r = e.data.ref;

    if (n(r)) {
      var i = e.context,
          o = e.componentInstance || e.elm,
          a = i.$refs;
      t ? Array.isArray(a[r]) ? h(a[r], o) : a[r] === o && (a[r] = void 0) : e.data.refInFor ? Array.isArray(a[r]) ? a[r].indexOf(o) < 0 && a[r].push(o) : a[r] = [o] : a[r] = o;
    }
  }

  var nr = new pe("", {}, []),
      rr = ["create", "activate", "update", "remove", "destroy"];

  function ir(e, i) {
    return e.key === i.key && (e.tag === i.tag && e.isComment === i.isComment && n(e.data) === n(i.data) && function (e, t) {
      if ("input" !== e.tag) return !0;
      var r,
          i = n(r = e.data) && n(r = r.attrs) && r.type,
          o = n(r = t.data) && n(r = r.attrs) && r.type;
      return i === o || Xn(i) && Xn(o);
    }(e, i) || r(e.isAsyncPlaceholder) && e.asyncFactory === i.asyncFactory && t(i.asyncFactory.error));
  }

  function or(e, t, r) {
    var i,
        o,
        a = {};

    for (i = t; i <= r; ++i) n(o = e[i].key) && (a[o] = i);

    return a;
  }

  var ar = {
    create: sr,
    update: sr,
    destroy: function (e) {
      sr(e, nr);
    }
  };

  function sr(e, t) {
    (e.data.directives || t.data.directives) && function (e, t) {
      var n,
          r,
          i,
          o = e === nr,
          a = t === nr,
          s = ur(e.data.directives, e.context),
          c = ur(t.data.directives, t.context),
          u = [],
          l = [];

      for (n in c) r = s[n], i = c[n], r ? (i.oldValue = r.value, i.oldArg = r.arg, fr(i, "update", t, e), i.def && i.def.componentUpdated && l.push(i)) : (fr(i, "bind", t, e), i.def && i.def.inserted && u.push(i));

      if (u.length) {
        var f = function () {
          for (var n = 0; n < u.length; n++) fr(u[n], "inserted", t, e);
        };

        o ? it(t, "insert", f) : f();
      }

      l.length && it(t, "postpatch", function () {
        for (var n = 0; n < l.length; n++) fr(l[n], "componentUpdated", t, e);
      });
      if (!o) for (n in s) c[n] || fr(s[n], "unbind", e, e, a);
    }(e, t);
  }

  var cr = Object.create(null);

  function ur(e, t) {
    var n,
        r,
        i = Object.create(null);
    if (!e) return i;

    for (n = 0; n < e.length; n++) (r = e[n]).modifiers || (r.modifiers = cr), i[lr(r)] = r, r.def = Le(t.$options, "directives", r.name);

    return i;
  }

  function lr(e) {
    return e.rawName || e.name + "." + Object.keys(e.modifiers || {}).join(".");
  }

  function fr(e, t, n, r, i) {
    var o = e.def && e.def[t];
    if (o) try {
      o(n.elm, e, n, r, i);
    } catch (r) {
      Re(r, n.context, "directive " + e.name + " " + t + " hook");
    }
  }

  var pr = [er, ar];

  function dr(e, r) {
    var i = r.componentOptions;

    if (!(n(i) && !1 === i.Ctor.options.inheritAttrs || t(e.data.attrs) && t(r.data.attrs))) {
      var o,
          a,
          s = r.elm,
          c = e.data.attrs || {},
          u = r.data.attrs || {};

      for (o in n(u.__ob__) && (u = r.data.attrs = A({}, u)), u) a = u[o], c[o] !== a && vr(s, o, a);

      for (o in (q || Z) && u.value !== c.value && vr(s, "value", u.value), c) t(u[o]) && (Pn(o) ? s.removeAttributeNS(Fn, Rn(o)) : Dn(o) || s.removeAttribute(o));
    }
  }

  function vr(e, t, n) {
    e.tagName.indexOf("-") > -1 ? hr(e, t, n) : In(t) ? Hn(n) ? e.removeAttribute(t) : (n = "allowfullscreen" === t && "EMBED" === e.tagName ? "true" : t, e.setAttribute(t, n)) : Dn(t) ? e.setAttribute(t, Mn(t, n)) : Pn(t) ? Hn(n) ? e.removeAttributeNS(Fn, Rn(t)) : e.setAttributeNS(Fn, t, n) : hr(e, t, n);
  }

  function hr(e, t, n) {
    if (Hn(n)) e.removeAttribute(t);else {
      if (q && !W && "TEXTAREA" === e.tagName && "placeholder" === t && "" !== n && !e.__ieph) {
        var r = function (t) {
          t.stopImmediatePropagation(), e.removeEventListener("input", r);
        };

        e.addEventListener("input", r), e.__ieph = !0;
      }

      e.setAttribute(t, n);
    }
  }

  var mr = {
    create: dr,
    update: dr
  };

  function yr(e, r) {
    var i = r.elm,
        o = r.data,
        a = e.data;

    if (!(t(o.staticClass) && t(o.class) && (t(a) || t(a.staticClass) && t(a.class)))) {
      var s = Bn(r),
          c = i._transitionClasses;
      n(c) && (s = zn(s, Vn(c))), s !== i._prevClass && (i.setAttribute("class", s), i._prevClass = s);
    }
  }

  var gr,
      _r,
      br,
      $r,
      wr,
      Cr,
      xr = {
    create: yr,
    update: yr
  },
      kr = /[\w).+\-_$\]]/;

  function Ar(e) {
    var t,
        n,
        r,
        i,
        o,
        a = !1,
        s = !1,
        c = !1,
        u = !1,
        l = 0,
        f = 0,
        p = 0,
        d = 0;

    for (r = 0; r < e.length; r++) if (n = t, t = e.charCodeAt(r), a) 39 === t && 92 !== n && (a = !1);else if (s) 34 === t && 92 !== n && (s = !1);else if (c) 96 === t && 92 !== n && (c = !1);else if (u) 47 === t && 92 !== n && (u = !1);else if (124 !== t || 124 === e.charCodeAt(r + 1) || 124 === e.charCodeAt(r - 1) || l || f || p) {
      switch (t) {
        case 34:
          s = !0;
          break;

        case 39:
          a = !0;
          break;

        case 96:
          c = !0;
          break;

        case 40:
          p++;
          break;

        case 41:
          p--;
          break;

        case 91:
          f++;
          break;

        case 93:
          f--;
          break;

        case 123:
          l++;
          break;

        case 125:
          l--;
      }

      if (47 === t) {
        for (var v = r - 1, h = void 0; v >= 0 && " " === (h = e.charAt(v)); v--);

        h && kr.test(h) || (u = !0);
      }
    } else void 0 === i ? (d = r + 1, i = e.slice(0, r).trim()) : m();

    function m() {
      (o || (o = [])).push(e.slice(d, r).trim()), d = r + 1;
    }

    if (void 0 === i ? i = e.slice(0, r).trim() : 0 !== d && m(), o) for (r = 0; r < o.length; r++) i = Or(i, o[r]);
    return i;
  }

  function Or(e, t) {
    var n = t.indexOf("(");
    if (n < 0) return '_f("' + t + '")(' + e + ")";
    var r = t.slice(0, n),
        i = t.slice(n + 1);
    return '_f("' + r + '")(' + e + (")" !== i ? "," + i : i);
  }

  function Sr(e, t) {
    console.error("[Vue compiler]: " + e);
  }

  function Tr(e, t) {
    return e ? e.map(function (e) {
      return e[t];
    }).filter(function (e) {
      return e;
    }) : [];
  }

  function Er(e, t, n, r, i) {
    (e.props || (e.props = [])).push(Rr({
      name: t,
      value: n,
      dynamic: i
    }, r)), e.plain = !1;
  }

  function Nr(e, t, n, r, i) {
    (i ? e.dynamicAttrs || (e.dynamicAttrs = []) : e.attrs || (e.attrs = [])).push(Rr({
      name: t,
      value: n,
      dynamic: i
    }, r)), e.plain = !1;
  }

  function jr(e, t, n, r) {
    e.attrsMap[t] = n, e.attrsList.push(Rr({
      name: t,
      value: n
    }, r));
  }

  function Dr(e, t, n, r, i, o, a, s) {
    (e.directives || (e.directives = [])).push(Rr({
      name: t,
      rawName: n,
      value: r,
      arg: i,
      isDynamicArg: o,
      modifiers: a
    }, s)), e.plain = !1;
  }

  function Lr(e, t, n) {
    return n ? "_p(" + t + ',"' + e + '")' : e + t;
  }

  function Mr(t, n, r, i, o, a, s, c) {
    var u;
    (i = i || e).right ? c ? n = "(" + n + ")==='click'?'contextmenu':(" + n + ")" : "click" === n && (n = "contextmenu", delete i.right) : i.middle && (c ? n = "(" + n + ")==='click'?'mouseup':(" + n + ")" : "click" === n && (n = "mouseup")), i.capture && (delete i.capture, n = Lr("!", n, c)), i.once && (delete i.once, n = Lr("~", n, c)), i.passive && (delete i.passive, n = Lr("&", n, c)), i.native ? (delete i.native, u = t.nativeEvents || (t.nativeEvents = {})) : u = t.events || (t.events = {});
    var l = Rr({
      value: r.trim(),
      dynamic: c
    }, s);
    i !== e && (l.modifiers = i);
    var f = u[n];
    Array.isArray(f) ? o ? f.unshift(l) : f.push(l) : u[n] = f ? o ? [l, f] : [f, l] : l, t.plain = !1;
  }

  function Ir(e, t, n) {
    var r = Fr(e, ":" + t) || Fr(e, "v-bind:" + t);
    if (null != r) return Ar(r);

    if (!1 !== n) {
      var i = Fr(e, t);
      if (null != i) return JSON.stringify(i);
    }
  }

  function Fr(e, t, n) {
    var r;
    if (null != (r = e.attrsMap[t])) for (var i = e.attrsList, o = 0, a = i.length; o < a; o++) if (i[o].name === t) {
      i.splice(o, 1);
      break;
    }
    return n && delete e.attrsMap[t], r;
  }

  function Pr(e, t) {
    for (var n = e.attrsList, r = 0, i = n.length; r < i; r++) {
      var o = n[r];
      if (t.test(o.name)) return n.splice(r, 1), o;
    }
  }

  function Rr(e, t) {
    return t && (null != t.start && (e.start = t.start), null != t.end && (e.end = t.end)), e;
  }

  function Hr(e, t, n) {
    var r = n || {},
        i = r.number,
        o = "$$v";
    r.trim && (o = "(typeof $$v === 'string'? $$v.trim(): $$v)"), i && (o = "_n(" + o + ")");
    var a = Br(t, o);
    e.model = {
      value: "(" + t + ")",
      expression: JSON.stringify(t),
      callback: "function ($$v) {" + a + "}"
    };
  }

  function Br(e, t) {
    var n = function (e) {
      if (e = e.trim(), gr = e.length, e.indexOf("[") < 0 || e.lastIndexOf("]") < gr - 1) return ($r = e.lastIndexOf(".")) > -1 ? {
        exp: e.slice(0, $r),
        key: '"' + e.slice($r + 1) + '"'
      } : {
        exp: e,
        key: null
      };
      _r = e, $r = wr = Cr = 0;

      for (; !zr();) Vr(br = Ur()) ? Jr(br) : 91 === br && Kr(br);

      return {
        exp: e.slice(0, wr),
        key: e.slice(wr + 1, Cr)
      };
    }(e);

    return null === n.key ? e + "=" + t : "$set(" + n.exp + ", " + n.key + ", " + t + ")";
  }

  function Ur() {
    return _r.charCodeAt(++$r);
  }

  function zr() {
    return $r >= gr;
  }

  function Vr(e) {
    return 34 === e || 39 === e;
  }

  function Kr(e) {
    var t = 1;

    for (wr = $r; !zr();) if (Vr(e = Ur())) Jr(e);else if (91 === e && t++, 93 === e && t--, 0 === t) {
      Cr = $r;
      break;
    }
  }

  function Jr(e) {
    for (var t = e; !zr() && (e = Ur()) !== t;);
  }

  var qr,
      Wr = "__r",
      Zr = "__c";

  function Gr(e, t, n) {
    var r = qr;
    return function i() {
      null !== t.apply(null, arguments) && Qr(e, i, n, r);
    };
  }

  var Xr = Ve && !(X && Number(X[1]) <= 53);

  function Yr(e, t, n, r) {
    if (Xr) {
      var i = an,
          o = t;

      t = o._wrapper = function (e) {
        if (e.target === e.currentTarget || e.timeStamp >= i || e.timeStamp <= 0 || e.target.ownerDocument !== document) return o.apply(this, arguments);
      };
    }

    qr.addEventListener(e, t, Q ? {
      capture: n,
      passive: r
    } : n);
  }

  function Qr(e, t, n, r) {
    (r || qr).removeEventListener(e, t._wrapper || t, n);
  }

  function ei(e, r) {
    if (!t(e.data.on) || !t(r.data.on)) {
      var i = r.data.on || {},
          o = e.data.on || {};
      qr = r.elm, function (e) {
        if (n(e[Wr])) {
          var t = q ? "change" : "input";
          e[t] = [].concat(e[Wr], e[t] || []), delete e[Wr];
        }

        n(e[Zr]) && (e.change = [].concat(e[Zr], e.change || []), delete e[Zr]);
      }(i), rt(i, o, Yr, Qr, Gr, r.context), qr = void 0;
    }
  }

  var ti,
      ni = {
    create: ei,
    update: ei
  };

  function ri(e, r) {
    if (!t(e.data.domProps) || !t(r.data.domProps)) {
      var i,
          o,
          a = r.elm,
          s = e.data.domProps || {},
          c = r.data.domProps || {};

      for (i in n(c.__ob__) && (c = r.data.domProps = A({}, c)), s) i in c || (a[i] = "");

      for (i in c) {
        if (o = c[i], "textContent" === i || "innerHTML" === i) {
          if (r.children && (r.children.length = 0), o === s[i]) continue;
          1 === a.childNodes.length && a.removeChild(a.childNodes[0]);
        }

        if ("value" === i && "PROGRESS" !== a.tagName) {
          a._value = o;
          var u = t(o) ? "" : String(o);
          ii(a, u) && (a.value = u);
        } else if ("innerHTML" === i && qn(a.tagName) && t(a.innerHTML)) {
          (ti = ti || document.createElement("div")).innerHTML = "<svg>" + o + "</svg>";

          for (var l = ti.firstChild; a.firstChild;) a.removeChild(a.firstChild);

          for (; l.firstChild;) a.appendChild(l.firstChild);
        } else if (o !== s[i]) try {
          a[i] = o;
        } catch (e) {}
      }
    }
  }

  function ii(e, t) {
    return !e.composing && ("OPTION" === e.tagName || function (e, t) {
      var n = !0;

      try {
        n = document.activeElement !== e;
      } catch (e) {}

      return n && e.value !== t;
    }(e, t) || function (e, t) {
      var r = e.value,
          i = e._vModifiers;

      if (n(i)) {
        if (i.number) return f(r) !== f(t);
        if (i.trim) return r.trim() !== t.trim();
      }

      return r !== t;
    }(e, t));
  }

  var oi = {
    create: ri,
    update: ri
  },
      ai = g(function (e) {
    var t = {},
        n = /:(.+)/;
    return e.split(/;(?![^(]*\))/g).forEach(function (e) {
      if (e) {
        var r = e.split(n);
        r.length > 1 && (t[r[0].trim()] = r[1].trim());
      }
    }), t;
  });

  function si(e) {
    var t = ci(e.style);
    return e.staticStyle ? A(e.staticStyle, t) : t;
  }

  function ci(e) {
    return Array.isArray(e) ? O(e) : "string" == typeof e ? ai(e) : e;
  }

  var ui,
      li = /^--/,
      fi = /\s*!important$/,
      pi = function (e, t, n) {
    if (li.test(t)) e.style.setProperty(t, n);else if (fi.test(n)) e.style.setProperty(C(t), n.replace(fi, ""), "important");else {
      var r = vi(t);
      if (Array.isArray(n)) for (var i = 0, o = n.length; i < o; i++) e.style[r] = n[i];else e.style[r] = n;
    }
  },
      di = ["Webkit", "Moz", "ms"],
      vi = g(function (e) {
    if (ui = ui || document.createElement("div").style, "filter" !== (e = b(e)) && e in ui) return e;

    for (var t = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < di.length; n++) {
      var r = di[n] + t;
      if (r in ui) return r;
    }
  });

  function hi(e, r) {
    var i = r.data,
        o = e.data;

    if (!(t(i.staticStyle) && t(i.style) && t(o.staticStyle) && t(o.style))) {
      var a,
          s,
          c = r.elm,
          u = o.staticStyle,
          l = o.normalizedStyle || o.style || {},
          f = u || l,
          p = ci(r.data.style) || {};
      r.data.normalizedStyle = n(p.__ob__) ? A({}, p) : p;

      var d = function (e, t) {
        var n,
            r = {};
        if (t) for (var i = e; i.componentInstance;) (i = i.componentInstance._vnode) && i.data && (n = si(i.data)) && A(r, n);
        (n = si(e.data)) && A(r, n);

        for (var o = e; o = o.parent;) o.data && (n = si(o.data)) && A(r, n);

        return r;
      }(r, !0);

      for (s in f) t(d[s]) && pi(c, s, "");

      for (s in d) (a = d[s]) !== f[s] && pi(c, s, null == a ? "" : a);
    }
  }

  var mi = {
    create: hi,
    update: hi
  },
      yi = /\s+/;

  function gi(e, t) {
    if (t && (t = t.trim())) if (e.classList) t.indexOf(" ") > -1 ? t.split(yi).forEach(function (t) {
      return e.classList.add(t);
    }) : e.classList.add(t);else {
      var n = " " + (e.getAttribute("class") || "") + " ";
      n.indexOf(" " + t + " ") < 0 && e.setAttribute("class", (n + t).trim());
    }
  }

  function _i(e, t) {
    if (t && (t = t.trim())) if (e.classList) t.indexOf(" ") > -1 ? t.split(yi).forEach(function (t) {
      return e.classList.remove(t);
    }) : e.classList.remove(t), e.classList.length || e.removeAttribute("class");else {
      for (var n = " " + (e.getAttribute("class") || "") + " ", r = " " + t + " "; n.indexOf(r) >= 0;) n = n.replace(r, " ");

      (n = n.trim()) ? e.setAttribute("class", n) : e.removeAttribute("class");
    }
  }

  function bi(e) {
    if (e) {
      if ("object" == typeof e) {
        var t = {};
        return !1 !== e.css && A(t, $i(e.name || "v")), A(t, e), t;
      }

      return "string" == typeof e ? $i(e) : void 0;
    }
  }

  var $i = g(function (e) {
    return {
      enterClass: e + "-enter",
      enterToClass: e + "-enter-to",
      enterActiveClass: e + "-enter-active",
      leaveClass: e + "-leave",
      leaveToClass: e + "-leave-to",
      leaveActiveClass: e + "-leave-active"
    };
  }),
      wi = z && !W,
      Ci = "transition",
      xi = "animation",
      ki = "transition",
      Ai = "transitionend",
      Oi = "animation",
      Si = "animationend";
  wi && (void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (ki = "WebkitTransition", Ai = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (Oi = "WebkitAnimation", Si = "webkitAnimationEnd"));
  var Ti = z ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function (e) {
    return e();
  };

  function Ei(e) {
    Ti(function () {
      Ti(e);
    });
  }

  function Ni(e, t) {
    var n = e._transitionClasses || (e._transitionClasses = []);
    n.indexOf(t) < 0 && (n.push(t), gi(e, t));
  }

  function ji(e, t) {
    e._transitionClasses && h(e._transitionClasses, t), _i(e, t);
  }

  function Di(e, t, n) {
    var r = Mi(e, t),
        i = r.type,
        o = r.timeout,
        a = r.propCount;
    if (!i) return n();

    var s = i === Ci ? Ai : Si,
        c = 0,
        u = function () {
      e.removeEventListener(s, l), n();
    },
        l = function (t) {
      t.target === e && ++c >= a && u();
    };

    setTimeout(function () {
      c < a && u();
    }, o + 1), e.addEventListener(s, l);
  }

  var Li = /\b(transform|all)(,|$)/;

  function Mi(e, t) {
    var n,
        r = window.getComputedStyle(e),
        i = (r[ki + "Delay"] || "").split(", "),
        o = (r[ki + "Duration"] || "").split(", "),
        a = Ii(i, o),
        s = (r[Oi + "Delay"] || "").split(", "),
        c = (r[Oi + "Duration"] || "").split(", "),
        u = Ii(s, c),
        l = 0,
        f = 0;
    return t === Ci ? a > 0 && (n = Ci, l = a, f = o.length) : t === xi ? u > 0 && (n = xi, l = u, f = c.length) : f = (n = (l = Math.max(a, u)) > 0 ? a > u ? Ci : xi : null) ? n === Ci ? o.length : c.length : 0, {
      type: n,
      timeout: l,
      propCount: f,
      hasTransform: n === Ci && Li.test(r[ki + "Property"])
    };
  }

  function Ii(e, t) {
    for (; e.length < t.length;) e = e.concat(e);

    return Math.max.apply(null, t.map(function (t, n) {
      return Fi(t) + Fi(e[n]);
    }));
  }

  function Fi(e) {
    return 1e3 * Number(e.slice(0, -1).replace(",", "."));
  }

  function Pi(e, r) {
    var i = e.elm;
    n(i._leaveCb) && (i._leaveCb.cancelled = !0, i._leaveCb());
    var a = bi(e.data.transition);

    if (!t(a) && !n(i._enterCb) && 1 === i.nodeType) {
      for (var s = a.css, c = a.type, u = a.enterClass, l = a.enterToClass, p = a.enterActiveClass, d = a.appearClass, v = a.appearToClass, h = a.appearActiveClass, m = a.beforeEnter, y = a.enter, g = a.afterEnter, _ = a.enterCancelled, b = a.beforeAppear, $ = a.appear, w = a.afterAppear, C = a.appearCancelled, x = a.duration, k = Wt, A = Wt.$vnode; A && A.parent;) k = A.context, A = A.parent;

      var O = !k._isMounted || !e.isRootInsert;

      if (!O || $ || "" === $) {
        var S = O && d ? d : u,
            T = O && h ? h : p,
            E = O && v ? v : l,
            N = O && b || m,
            j = O && "function" == typeof $ ? $ : y,
            L = O && w || g,
            M = O && C || _,
            I = f(o(x) ? x.enter : x),
            F = !1 !== s && !W,
            P = Bi(j),
            R = i._enterCb = D(function () {
          F && (ji(i, E), ji(i, T)), R.cancelled ? (F && ji(i, S), M && M(i)) : L && L(i), i._enterCb = null;
        });
        e.data.show || it(e, "insert", function () {
          var t = i.parentNode,
              n = t && t._pending && t._pending[e.key];
          n && n.tag === e.tag && n.elm._leaveCb && n.elm._leaveCb(), j && j(i, R);
        }), N && N(i), F && (Ni(i, S), Ni(i, T), Ei(function () {
          ji(i, S), R.cancelled || (Ni(i, E), P || (Hi(I) ? setTimeout(R, I) : Di(i, c, R)));
        })), e.data.show && (r && r(), j && j(i, R)), F || P || R();
      }
    }
  }

  function Ri(e, r) {
    var i = e.elm;
    n(i._enterCb) && (i._enterCb.cancelled = !0, i._enterCb());
    var a = bi(e.data.transition);
    if (t(a) || 1 !== i.nodeType) return r();

    if (!n(i._leaveCb)) {
      var s = a.css,
          c = a.type,
          u = a.leaveClass,
          l = a.leaveToClass,
          p = a.leaveActiveClass,
          d = a.beforeLeave,
          v = a.leave,
          h = a.afterLeave,
          m = a.leaveCancelled,
          y = a.delayLeave,
          g = a.duration,
          _ = !1 !== s && !W,
          b = Bi(v),
          $ = f(o(g) ? g.leave : g),
          w = i._leaveCb = D(function () {
        i.parentNode && i.parentNode._pending && (i.parentNode._pending[e.key] = null), _ && (ji(i, l), ji(i, p)), w.cancelled ? (_ && ji(i, u), m && m(i)) : (r(), h && h(i)), i._leaveCb = null;
      });

      y ? y(C) : C();
    }

    function C() {
      w.cancelled || (!e.data.show && i.parentNode && ((i.parentNode._pending || (i.parentNode._pending = {}))[e.key] = e), d && d(i), _ && (Ni(i, u), Ni(i, p), Ei(function () {
        ji(i, u), w.cancelled || (Ni(i, l), b || (Hi($) ? setTimeout(w, $) : Di(i, c, w)));
      })), v && v(i, w), _ || b || w());
    }
  }

  function Hi(e) {
    return "number" == typeof e && !isNaN(e);
  }

  function Bi(e) {
    if (t(e)) return !1;
    var r = e.fns;
    return n(r) ? Bi(Array.isArray(r) ? r[0] : r) : (e._length || e.length) > 1;
  }

  function Ui(e, t) {
    !0 !== t.data.show && Pi(t);
  }

  var zi = function (e) {
    var o,
        a,
        s = {},
        c = e.modules,
        u = e.nodeOps;

    for (o = 0; o < rr.length; ++o) for (s[rr[o]] = [], a = 0; a < c.length; ++a) n(c[a][rr[o]]) && s[rr[o]].push(c[a][rr[o]]);

    function l(e) {
      var t = u.parentNode(e);
      n(t) && u.removeChild(t, e);
    }

    function f(e, t, i, o, a, c, l) {
      if (n(e.elm) && n(c) && (e = c[l] = me(e)), e.isRootInsert = !a, !function (e, t, i, o) {
        var a = e.data;

        if (n(a)) {
          var c = n(e.componentInstance) && a.keepAlive;
          if (n(a = a.hook) && n(a = a.init) && a(e, !1), n(e.componentInstance)) return d(e, t), v(i, e.elm, o), r(c) && function (e, t, r, i) {
            for (var o, a = e; a.componentInstance;) if (a = a.componentInstance._vnode, n(o = a.data) && n(o = o.transition)) {
              for (o = 0; o < s.activate.length; ++o) s.activate[o](nr, a);

              t.push(a);
              break;
            }

            v(r, e.elm, i);
          }(e, t, i, o), !0;
        }
      }(e, t, i, o)) {
        var f = e.data,
            p = e.children,
            m = e.tag;
        n(m) ? (e.elm = e.ns ? u.createElementNS(e.ns, m) : u.createElement(m, e), g(e), h(e, p, t), n(f) && y(e, t), v(i, e.elm, o)) : r(e.isComment) ? (e.elm = u.createComment(e.text), v(i, e.elm, o)) : (e.elm = u.createTextNode(e.text), v(i, e.elm, o));
      }
    }

    function d(e, t) {
      n(e.data.pendingInsert) && (t.push.apply(t, e.data.pendingInsert), e.data.pendingInsert = null), e.elm = e.componentInstance.$el, m(e) ? (y(e, t), g(e)) : (tr(e), t.push(e));
    }

    function v(e, t, r) {
      n(e) && (n(r) ? u.parentNode(r) === e && u.insertBefore(e, t, r) : u.appendChild(e, t));
    }

    function h(e, t, n) {
      if (Array.isArray(t)) for (var r = 0; r < t.length; ++r) f(t[r], n, e.elm, null, !0, t, r);else i(e.text) && u.appendChild(e.elm, u.createTextNode(String(e.text)));
    }

    function m(e) {
      for (; e.componentInstance;) e = e.componentInstance._vnode;

      return n(e.tag);
    }

    function y(e, t) {
      for (var r = 0; r < s.create.length; ++r) s.create[r](nr, e);

      n(o = e.data.hook) && (n(o.create) && o.create(nr, e), n(o.insert) && t.push(e));
    }

    function g(e) {
      var t;
      if (n(t = e.fnScopeId)) u.setStyleScope(e.elm, t);else for (var r = e; r;) n(t = r.context) && n(t = t.$options._scopeId) && u.setStyleScope(e.elm, t), r = r.parent;
      n(t = Wt) && t !== e.context && t !== e.fnContext && n(t = t.$options._scopeId) && u.setStyleScope(e.elm, t);
    }

    function _(e, t, n, r, i, o) {
      for (; r <= i; ++r) f(n[r], o, e, t, !1, n, r);
    }

    function b(e) {
      var t,
          r,
          i = e.data;
      if (n(i)) for (n(t = i.hook) && n(t = t.destroy) && t(e), t = 0; t < s.destroy.length; ++t) s.destroy[t](e);
      if (n(t = e.children)) for (r = 0; r < e.children.length; ++r) b(e.children[r]);
    }

    function $(e, t, r) {
      for (; t <= r; ++t) {
        var i = e[t];
        n(i) && (n(i.tag) ? (w(i), b(i)) : l(i.elm));
      }
    }

    function w(e, t) {
      if (n(t) || n(e.data)) {
        var r,
            i = s.remove.length + 1;

        for (n(t) ? t.listeners += i : t = function (e, t) {
          function n() {
            0 == --n.listeners && l(e);
          }

          return n.listeners = t, n;
        }(e.elm, i), n(r = e.componentInstance) && n(r = r._vnode) && n(r.data) && w(r, t), r = 0; r < s.remove.length; ++r) s.remove[r](e, t);

        n(r = e.data.hook) && n(r = r.remove) ? r(e, t) : t();
      } else l(e.elm);
    }

    function C(e, t, r, i) {
      for (var o = r; o < i; o++) {
        var a = t[o];
        if (n(a) && ir(e, a)) return o;
      }
    }

    function x(e, i, o, a, c, l) {
      if (e !== i) {
        n(i.elm) && n(a) && (i = a[c] = me(i));
        var p = i.elm = e.elm;
        if (r(e.isAsyncPlaceholder)) n(i.asyncFactory.resolved) ? O(e.elm, i, o) : i.isAsyncPlaceholder = !0;else if (r(i.isStatic) && r(e.isStatic) && i.key === e.key && (r(i.isCloned) || r(i.isOnce))) i.componentInstance = e.componentInstance;else {
          var d,
              v = i.data;
          n(v) && n(d = v.hook) && n(d = d.prepatch) && d(e, i);
          var h = e.children,
              y = i.children;

          if (n(v) && m(i)) {
            for (d = 0; d < s.update.length; ++d) s.update[d](e, i);

            n(d = v.hook) && n(d = d.update) && d(e, i);
          }

          t(i.text) ? n(h) && n(y) ? h !== y && function (e, r, i, o, a) {
            for (var s, c, l, p = 0, d = 0, v = r.length - 1, h = r[0], m = r[v], y = i.length - 1, g = i[0], b = i[y], w = !a; p <= v && d <= y;) t(h) ? h = r[++p] : t(m) ? m = r[--v] : ir(h, g) ? (x(h, g, o, i, d), h = r[++p], g = i[++d]) : ir(m, b) ? (x(m, b, o, i, y), m = r[--v], b = i[--y]) : ir(h, b) ? (x(h, b, o, i, y), w && u.insertBefore(e, h.elm, u.nextSibling(m.elm)), h = r[++p], b = i[--y]) : ir(m, g) ? (x(m, g, o, i, d), w && u.insertBefore(e, m.elm, h.elm), m = r[--v], g = i[++d]) : (t(s) && (s = or(r, p, v)), t(c = n(g.key) ? s[g.key] : C(g, r, p, v)) ? f(g, o, e, h.elm, !1, i, d) : ir(l = r[c], g) ? (x(l, g, o, i, d), r[c] = void 0, w && u.insertBefore(e, l.elm, h.elm)) : f(g, o, e, h.elm, !1, i, d), g = i[++d]);

            p > v ? _(e, t(i[y + 1]) ? null : i[y + 1].elm, i, d, y, o) : d > y && $(r, p, v);
          }(p, h, y, o, l) : n(y) ? (n(e.text) && u.setTextContent(p, ""), _(p, null, y, 0, y.length - 1, o)) : n(h) ? $(h, 0, h.length - 1) : n(e.text) && u.setTextContent(p, "") : e.text !== i.text && u.setTextContent(p, i.text), n(v) && n(d = v.hook) && n(d = d.postpatch) && d(e, i);
        }
      }
    }

    function k(e, t, i) {
      if (r(i) && n(e.parent)) e.parent.data.pendingInsert = t;else for (var o = 0; o < t.length; ++o) t[o].data.hook.insert(t[o]);
    }

    var A = p("attrs,class,staticClass,staticStyle,key");

    function O(e, t, i, o) {
      var a,
          s = t.tag,
          c = t.data,
          u = t.children;
      if (o = o || c && c.pre, t.elm = e, r(t.isComment) && n(t.asyncFactory)) return t.isAsyncPlaceholder = !0, !0;
      if (n(c) && (n(a = c.hook) && n(a = a.init) && a(t, !0), n(a = t.componentInstance))) return d(t, i), !0;

      if (n(s)) {
        if (n(u)) if (e.hasChildNodes()) {
          if (n(a = c) && n(a = a.domProps) && n(a = a.innerHTML)) {
            if (a !== e.innerHTML) return !1;
          } else {
            for (var l = !0, f = e.firstChild, p = 0; p < u.length; p++) {
              if (!f || !O(f, u[p], i, o)) {
                l = !1;
                break;
              }

              f = f.nextSibling;
            }

            if (!l || f) return !1;
          }
        } else h(t, u, i);

        if (n(c)) {
          var v = !1;

          for (var m in c) if (!A(m)) {
            v = !0, y(t, i);
            break;
          }

          !v && c.class && et(c.class);
        }
      } else e.data !== t.text && (e.data = t.text);

      return !0;
    }

    return function (e, i, o, a) {
      if (!t(i)) {
        var c,
            l = !1,
            p = [];
        if (t(e)) l = !0, f(i, p);else {
          var d = n(e.nodeType);
          if (!d && ir(e, i)) x(e, i, p, null, null, a);else {
            if (d) {
              if (1 === e.nodeType && e.hasAttribute(L) && (e.removeAttribute(L), o = !0), r(o) && O(e, i, p)) return k(i, p, !0), e;
              c = e, e = new pe(u.tagName(c).toLowerCase(), {}, [], void 0, c);
            }

            var v = e.elm,
                h = u.parentNode(v);
            if (f(i, p, v._leaveCb ? null : h, u.nextSibling(v)), n(i.parent)) for (var y = i.parent, g = m(i); y;) {
              for (var _ = 0; _ < s.destroy.length; ++_) s.destroy[_](y);

              if (y.elm = i.elm, g) {
                for (var w = 0; w < s.create.length; ++w) s.create[w](nr, y);

                var C = y.data.hook.insert;
                if (C.merged) for (var A = 1; A < C.fns.length; A++) C.fns[A]();
              } else tr(y);

              y = y.parent;
            }
            n(h) ? $([e], 0, 0) : n(e.tag) && b(e);
          }
        }
        return k(i, p, l), i.elm;
      }

      n(e) && b(e);
    };
  }({
    nodeOps: Qn,
    modules: [mr, xr, ni, oi, mi, z ? {
      create: Ui,
      activate: Ui,
      remove: function (e, t) {
        !0 !== e.data.show ? Ri(e, t) : t();
      }
    } : {}].concat(pr)
  });

  W && document.addEventListener("selectionchange", function () {
    var e = document.activeElement;
    e && e.vmodel && Xi(e, "input");
  });
  var Vi = {
    inserted: function (e, t, n, r) {
      "select" === n.tag ? (r.elm && !r.elm._vOptions ? it(n, "postpatch", function () {
        Vi.componentUpdated(e, t, n);
      }) : Ki(e, t, n.context), e._vOptions = [].map.call(e.options, Wi)) : ("textarea" === n.tag || Xn(e.type)) && (e._vModifiers = t.modifiers, t.modifiers.lazy || (e.addEventListener("compositionstart", Zi), e.addEventListener("compositionend", Gi), e.addEventListener("change", Gi), W && (e.vmodel = !0)));
    },
    componentUpdated: function (e, t, n) {
      if ("select" === n.tag) {
        Ki(e, t, n.context);
        var r = e._vOptions,
            i = e._vOptions = [].map.call(e.options, Wi);
        if (i.some(function (e, t) {
          return !N(e, r[t]);
        })) (e.multiple ? t.value.some(function (e) {
          return qi(e, i);
        }) : t.value !== t.oldValue && qi(t.value, i)) && Xi(e, "change");
      }
    }
  };

  function Ki(e, t, n) {
    Ji(e, t, n), (q || Z) && setTimeout(function () {
      Ji(e, t, n);
    }, 0);
  }

  function Ji(e, t, n) {
    var r = t.value,
        i = e.multiple;

    if (!i || Array.isArray(r)) {
      for (var o, a, s = 0, c = e.options.length; s < c; s++) if (a = e.options[s], i) o = j(r, Wi(a)) > -1, a.selected !== o && (a.selected = o);else if (N(Wi(a), r)) return void (e.selectedIndex !== s && (e.selectedIndex = s));

      i || (e.selectedIndex = -1);
    }
  }

  function qi(e, t) {
    return t.every(function (t) {
      return !N(t, e);
    });
  }

  function Wi(e) {
    return "_value" in e ? e._value : e.value;
  }

  function Zi(e) {
    e.target.composing = !0;
  }

  function Gi(e) {
    e.target.composing && (e.target.composing = !1, Xi(e.target, "input"));
  }

  function Xi(e, t) {
    var n = document.createEvent("HTMLEvents");
    n.initEvent(t, !0, !0), e.dispatchEvent(n);
  }

  function Yi(e) {
    return !e.componentInstance || e.data && e.data.transition ? e : Yi(e.componentInstance._vnode);
  }

  var Qi = {
    model: Vi,
    show: {
      bind: function (e, t, n) {
        var r = t.value,
            i = (n = Yi(n)).data && n.data.transition,
            o = e.__vOriginalDisplay = "none" === e.style.display ? "" : e.style.display;
        r && i ? (n.data.show = !0, Pi(n, function () {
          e.style.display = o;
        })) : e.style.display = r ? o : "none";
      },
      update: function (e, t, n) {
        var r = t.value;
        !r != !t.oldValue && ((n = Yi(n)).data && n.data.transition ? (n.data.show = !0, r ? Pi(n, function () {
          e.style.display = e.__vOriginalDisplay;
        }) : Ri(n, function () {
          e.style.display = "none";
        })) : e.style.display = r ? e.__vOriginalDisplay : "none");
      },
      unbind: function (e, t, n, r, i) {
        i || (e.style.display = e.__vOriginalDisplay);
      }
    }
  },
      eo = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  };

  function to(e) {
    var t = e && e.componentOptions;
    return t && t.Ctor.options.abstract ? to(zt(t.children)) : e;
  }

  function no(e) {
    var t = {},
        n = e.$options;

    for (var r in n.propsData) t[r] = e[r];

    var i = n._parentListeners;

    for (var o in i) t[b(o)] = i[o];

    return t;
  }

  function ro(e, t) {
    if (/\d-keep-alive$/.test(t.tag)) return e("keep-alive", {
      props: t.componentOptions.propsData
    });
  }

  var io = function (e) {
    return e.tag || Ut(e);
  },
      oo = function (e) {
    return "show" === e.name;
  },
      ao = {
    name: "transition",
    props: eo,
    abstract: !0,
    render: function (e) {
      var t = this,
          n = this.$slots.default;

      if (n && (n = n.filter(io)).length) {
        var r = this.mode,
            o = n[0];
        if (function (e) {
          for (; e = e.parent;) if (e.data.transition) return !0;
        }(this.$vnode)) return o;
        var a = to(o);
        if (!a) return o;
        if (this._leaving) return ro(e, o);
        var s = "__transition-" + this._uid + "-";
        a.key = null == a.key ? a.isComment ? s + "comment" : s + a.tag : i(a.key) ? 0 === String(a.key).indexOf(s) ? a.key : s + a.key : a.key;
        var c = (a.data || (a.data = {})).transition = no(this),
            u = this._vnode,
            l = to(u);

        if (a.data.directives && a.data.directives.some(oo) && (a.data.show = !0), l && l.data && !function (e, t) {
          return t.key === e.key && t.tag === e.tag;
        }(a, l) && !Ut(l) && (!l.componentInstance || !l.componentInstance._vnode.isComment)) {
          var f = l.data.transition = A({}, c);
          if ("out-in" === r) return this._leaving = !0, it(f, "afterLeave", function () {
            t._leaving = !1, t.$forceUpdate();
          }), ro(e, o);

          if ("in-out" === r) {
            if (Ut(a)) return u;

            var p,
                d = function () {
              p();
            };

            it(c, "afterEnter", d), it(c, "enterCancelled", d), it(f, "delayLeave", function (e) {
              p = e;
            });
          }
        }

        return o;
      }
    }
  },
      so = A({
    tag: String,
    moveClass: String
  }, eo);

  function co(e) {
    e.elm._moveCb && e.elm._moveCb(), e.elm._enterCb && e.elm._enterCb();
  }

  function uo(e) {
    e.data.newPos = e.elm.getBoundingClientRect();
  }

  function lo(e) {
    var t = e.data.pos,
        n = e.data.newPos,
        r = t.left - n.left,
        i = t.top - n.top;

    if (r || i) {
      e.data.moved = !0;
      var o = e.elm.style;
      o.transform = o.WebkitTransform = "translate(" + r + "px," + i + "px)", o.transitionDuration = "0s";
    }
  }

  delete so.mode;
  var fo = {
    Transition: ao,
    TransitionGroup: {
      props: so,
      beforeMount: function () {
        var e = this,
            t = this._update;

        this._update = function (n, r) {
          var i = Zt(e);
          e.__patch__(e._vnode, e.kept, !1, !0), e._vnode = e.kept, i(), t.call(e, n, r);
        };
      },
      render: function (e) {
        for (var t = this.tag || this.$vnode.data.tag || "span", n = Object.create(null), r = this.prevChildren = this.children, i = this.$slots.default || [], o = this.children = [], a = no(this), s = 0; s < i.length; s++) {
          var c = i[s];
          c.tag && null != c.key && 0 !== String(c.key).indexOf("__vlist") && (o.push(c), n[c.key] = c, (c.data || (c.data = {})).transition = a);
        }

        if (r) {
          for (var u = [], l = [], f = 0; f < r.length; f++) {
            var p = r[f];
            p.data.transition = a, p.data.pos = p.elm.getBoundingClientRect(), n[p.key] ? u.push(p) : l.push(p);
          }

          this.kept = e(t, null, u), this.removed = l;
        }

        return e(t, null, o);
      },
      updated: function () {
        var e = this.prevChildren,
            t = this.moveClass || (this.name || "v") + "-move";
        e.length && this.hasMove(e[0].elm, t) && (e.forEach(co), e.forEach(uo), e.forEach(lo), this._reflow = document.body.offsetHeight, e.forEach(function (e) {
          if (e.data.moved) {
            var n = e.elm,
                r = n.style;
            Ni(n, t), r.transform = r.WebkitTransform = r.transitionDuration = "", n.addEventListener(Ai, n._moveCb = function e(r) {
              r && r.target !== n || r && !/transform$/.test(r.propertyName) || (n.removeEventListener(Ai, e), n._moveCb = null, ji(n, t));
            });
          }
        }));
      },
      methods: {
        hasMove: function (e, t) {
          if (!wi) return !1;
          if (this._hasMove) return this._hasMove;
          var n = e.cloneNode();
          e._transitionClasses && e._transitionClasses.forEach(function (e) {
            _i(n, e);
          }), gi(n, t), n.style.display = "none", this.$el.appendChild(n);
          var r = Mi(n);
          return this.$el.removeChild(n), this._hasMove = r.hasTransform;
        }
      }
    }
  };
  wn.config.mustUseProp = jn, wn.config.isReservedTag = Wn, wn.config.isReservedAttr = En, wn.config.getTagNamespace = Zn, wn.config.isUnknownElement = function (e) {
    if (!z) return !0;
    if (Wn(e)) return !1;
    if (e = e.toLowerCase(), null != Gn[e]) return Gn[e];
    var t = document.createElement(e);
    return e.indexOf("-") > -1 ? Gn[e] = t.constructor === window.HTMLUnknownElement || t.constructor === window.HTMLElement : Gn[e] = /HTMLUnknownElement/.test(t.toString());
  }, A(wn.options.directives, Qi), A(wn.options.components, fo), wn.prototype.__patch__ = z ? zi : S, wn.prototype.$mount = function (e, t) {
    return function (e, t, n) {
      var r;
      return e.$el = t, e.$options.render || (e.$options.render = ve), Yt(e, "beforeMount"), r = function () {
        e._update(e._render(), n);
      }, new fn(e, r, S, {
        before: function () {
          e._isMounted && !e._isDestroyed && Yt(e, "beforeUpdate");
        }
      }, !0), n = !1, null == e.$vnode && (e._isMounted = !0, Yt(e, "mounted")), e;
    }(this, e = e && z ? Yn(e) : void 0, t);
  }, z && setTimeout(function () {
    F.devtools && ne && ne.emit("init", wn);
  }, 0);
  var po = /\{\{((?:.|\r?\n)+?)\}\}/g,
      vo = /[-.*+?^${}()|[\]\/\\]/g,
      ho = g(function (e) {
    var t = e[0].replace(vo, "\\$&"),
        n = e[1].replace(vo, "\\$&");
    return new RegExp(t + "((?:.|\\n)+?)" + n, "g");
  });
  var mo = {
    staticKeys: ["staticClass"],
    transformNode: function (e, t) {
      t.warn;
      var n = Fr(e, "class");
      n && (e.staticClass = JSON.stringify(n));
      var r = Ir(e, "class", !1);
      r && (e.classBinding = r);
    },
    genData: function (e) {
      var t = "";
      return e.staticClass && (t += "staticClass:" + e.staticClass + ","), e.classBinding && (t += "class:" + e.classBinding + ","), t;
    }
  };

  var yo,
      go = {
    staticKeys: ["staticStyle"],
    transformNode: function (e, t) {
      t.warn;
      var n = Fr(e, "style");
      n && (e.staticStyle = JSON.stringify(ai(n)));
      var r = Ir(e, "style", !1);
      r && (e.styleBinding = r);
    },
    genData: function (e) {
      var t = "";
      return e.staticStyle && (t += "staticStyle:" + e.staticStyle + ","), e.styleBinding && (t += "style:(" + e.styleBinding + "),"), t;
    }
  },
      _o = function (e) {
    return (yo = yo || document.createElement("div")).innerHTML = e, yo.textContent;
  },
      bo = p("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),
      $o = p("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),
      wo = p("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),
      Co = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
      xo = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
      ko = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + P.source + "]*",
      Ao = "((?:" + ko + "\\:)?" + ko + ")",
      Oo = new RegExp("^<" + Ao),
      So = /^\s*(\/?)>/,
      To = new RegExp("^<\\/" + Ao + "[^>]*>"),
      Eo = /^<!DOCTYPE [^>]+>/i,
      No = /^<!\--/,
      jo = /^<!\[/,
      Do = p("script,style,textarea", !0),
      Lo = {},
      Mo = {
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&amp;": "&",
    "&#10;": "\n",
    "&#9;": "\t",
    "&#39;": "'"
  },
      Io = /&(?:lt|gt|quot|amp|#39);/g,
      Fo = /&(?:lt|gt|quot|amp|#39|#10|#9);/g,
      Po = p("pre,textarea", !0),
      Ro = function (e, t) {
    return e && Po(e) && "\n" === t[0];
  };

  function Ho(e, t) {
    var n = t ? Fo : Io;
    return e.replace(n, function (e) {
      return Mo[e];
    });
  }

  var Bo,
      Uo,
      zo,
      Vo,
      Ko,
      Jo,
      qo,
      Wo,
      Zo = /^@|^v-on:/,
      Go = /^v-|^@|^:|^#/,
      Xo = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,
      Yo = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
      Qo = /^\(|\)$/g,
      ea = /^\[.*\]$/,
      ta = /:(.*)$/,
      na = /^:|^\.|^v-bind:/,
      ra = /\.[^.\]]+(?=[^\]]*$)/g,
      ia = /^v-slot(:|$)|^#/,
      oa = /[\r\n]/,
      aa = /\s+/g,
      sa = g(_o),
      ca = "_empty_";

  function ua(e, t, n) {
    return {
      type: 1,
      tag: e,
      attrsList: t,
      attrsMap: ma(t),
      rawAttrsMap: {},
      parent: n,
      children: []
    };
  }

  function la(e, t) {
    Bo = t.warn || Sr, Jo = t.isPreTag || T, qo = t.mustUseProp || T, Wo = t.getTagNamespace || T;
    t.isReservedTag;
    zo = Tr(t.modules, "transformNode"), Vo = Tr(t.modules, "preTransformNode"), Ko = Tr(t.modules, "postTransformNode"), Uo = t.delimiters;
    var n,
        r,
        i = [],
        o = !1 !== t.preserveWhitespace,
        a = t.whitespace,
        s = !1,
        c = !1;

    function u(e) {
      if (l(e), s || e.processed || (e = fa(e, t)), i.length || e === n || n.if && (e.elseif || e.else) && da(n, {
        exp: e.elseif,
        block: e
      }), r && !e.forbidden) if (e.elseif || e.else) a = e, (u = function (e) {
        var t = e.length;

        for (; t--;) {
          if (1 === e[t].type) return e[t];
          e.pop();
        }
      }(r.children)) && u.if && da(u, {
        exp: a.elseif,
        block: a
      });else {
        if (e.slotScope) {
          var o = e.slotTarget || '"default"';
          (r.scopedSlots || (r.scopedSlots = {}))[o] = e;
        }

        r.children.push(e), e.parent = r;
      }
      var a, u;
      e.children = e.children.filter(function (e) {
        return !e.slotScope;
      }), l(e), e.pre && (s = !1), Jo(e.tag) && (c = !1);

      for (var f = 0; f < Ko.length; f++) Ko[f](e, t);
    }

    function l(e) {
      if (!c) for (var t; (t = e.children[e.children.length - 1]) && 3 === t.type && " " === t.text;) e.children.pop();
    }

    return function (e, t) {
      for (var n, r, i = [], o = t.expectHTML, a = t.isUnaryTag || T, s = t.canBeLeftOpenTag || T, c = 0; e;) {
        if (n = e, r && Do(r)) {
          var u = 0,
              l = r.toLowerCase(),
              f = Lo[l] || (Lo[l] = new RegExp("([\\s\\S]*?)(</" + l + "[^>]*>)", "i")),
              p = e.replace(f, function (e, n, r) {
            return u = r.length, Do(l) || "noscript" === l || (n = n.replace(/<!\--([\s\S]*?)-->/g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1")), Ro(l, n) && (n = n.slice(1)), t.chars && t.chars(n), "";
          });
          c += e.length - p.length, e = p, A(l, c - u, c);
        } else {
          var d = e.indexOf("<");

          if (0 === d) {
            if (No.test(e)) {
              var v = e.indexOf("--\x3e");

              if (v >= 0) {
                t.shouldKeepComment && t.comment(e.substring(4, v), c, c + v + 3), C(v + 3);
                continue;
              }
            }

            if (jo.test(e)) {
              var h = e.indexOf("]>");

              if (h >= 0) {
                C(h + 2);
                continue;
              }
            }

            var m = e.match(Eo);

            if (m) {
              C(m[0].length);
              continue;
            }

            var y = e.match(To);

            if (y) {
              var g = c;
              C(y[0].length), A(y[1], g, c);
              continue;
            }

            var _ = x();

            if (_) {
              k(_), Ro(_.tagName, e) && C(1);
              continue;
            }
          }

          var b = void 0,
              $ = void 0,
              w = void 0;

          if (d >= 0) {
            for ($ = e.slice(d); !(To.test($) || Oo.test($) || No.test($) || jo.test($) || (w = $.indexOf("<", 1)) < 0);) d += w, $ = e.slice(d);

            b = e.substring(0, d);
          }

          d < 0 && (b = e), b && C(b.length), t.chars && b && t.chars(b, c - b.length, c);
        }

        if (e === n) {
          t.chars && t.chars(e);
          break;
        }
      }

      function C(t) {
        c += t, e = e.substring(t);
      }

      function x() {
        var t = e.match(Oo);

        if (t) {
          var n,
              r,
              i = {
            tagName: t[1],
            attrs: [],
            start: c
          };

          for (C(t[0].length); !(n = e.match(So)) && (r = e.match(xo) || e.match(Co));) r.start = c, C(r[0].length), r.end = c, i.attrs.push(r);

          if (n) return i.unarySlash = n[1], C(n[0].length), i.end = c, i;
        }
      }

      function k(e) {
        var n = e.tagName,
            c = e.unarySlash;
        o && ("p" === r && wo(n) && A(r), s(n) && r === n && A(n));

        for (var u = a(n) || !!c, l = e.attrs.length, f = new Array(l), p = 0; p < l; p++) {
          var d = e.attrs[p],
              v = d[3] || d[4] || d[5] || "",
              h = "a" === n && "href" === d[1] ? t.shouldDecodeNewlinesForHref : t.shouldDecodeNewlines;
          f[p] = {
            name: d[1],
            value: Ho(v, h)
          };
        }

        u || (i.push({
          tag: n,
          lowerCasedTag: n.toLowerCase(),
          attrs: f,
          start: e.start,
          end: e.end
        }), r = n), t.start && t.start(n, f, u, e.start, e.end);
      }

      function A(e, n, o) {
        var a, s;
        if (null == n && (n = c), null == o && (o = c), e) for (s = e.toLowerCase(), a = i.length - 1; a >= 0 && i[a].lowerCasedTag !== s; a--);else a = 0;

        if (a >= 0) {
          for (var u = i.length - 1; u >= a; u--) t.end && t.end(i[u].tag, n, o);

          i.length = a, r = a && i[a - 1].tag;
        } else "br" === s ? t.start && t.start(e, [], !0, n, o) : "p" === s && (t.start && t.start(e, [], !1, n, o), t.end && t.end(e, n, o));
      }

      A();
    }(e, {
      warn: Bo,
      expectHTML: t.expectHTML,
      isUnaryTag: t.isUnaryTag,
      canBeLeftOpenTag: t.canBeLeftOpenTag,
      shouldDecodeNewlines: t.shouldDecodeNewlines,
      shouldDecodeNewlinesForHref: t.shouldDecodeNewlinesForHref,
      shouldKeepComment: t.comments,
      outputSourceRange: t.outputSourceRange,
      start: function (e, o, a, l, f) {
        var p = r && r.ns || Wo(e);
        q && "svg" === p && (o = function (e) {
          for (var t = [], n = 0; n < e.length; n++) {
            var r = e[n];
            ya.test(r.name) || (r.name = r.name.replace(ga, ""), t.push(r));
          }

          return t;
        }(o));
        var d,
            v = ua(e, o, r);
        p && (v.ns = p), "style" !== (d = v).tag && ("script" !== d.tag || d.attrsMap.type && "text/javascript" !== d.attrsMap.type) || te() || (v.forbidden = !0);

        for (var h = 0; h < Vo.length; h++) v = Vo[h](v, t) || v;

        s || (!function (e) {
          null != Fr(e, "v-pre") && (e.pre = !0);
        }(v), v.pre && (s = !0)), Jo(v.tag) && (c = !0), s ? function (e) {
          var t = e.attrsList,
              n = t.length;
          if (n) for (var r = e.attrs = new Array(n), i = 0; i < n; i++) r[i] = {
            name: t[i].name,
            value: JSON.stringify(t[i].value)
          }, null != t[i].start && (r[i].start = t[i].start, r[i].end = t[i].end);else e.pre || (e.plain = !0);
        }(v) : v.processed || (pa(v), function (e) {
          var t = Fr(e, "v-if");
          if (t) e.if = t, da(e, {
            exp: t,
            block: e
          });else {
            null != Fr(e, "v-else") && (e.else = !0);
            var n = Fr(e, "v-else-if");
            n && (e.elseif = n);
          }
        }(v), function (e) {
          null != Fr(e, "v-once") && (e.once = !0);
        }(v)), n || (n = v), a ? u(v) : (r = v, i.push(v));
      },
      end: function (e, t, n) {
        var o = i[i.length - 1];
        i.length -= 1, r = i[i.length - 1], u(o);
      },
      chars: function (e, t, n) {
        if (r && (!q || "textarea" !== r.tag || r.attrsMap.placeholder !== e)) {
          var i,
              u,
              l,
              f = r.children;
          if (e = c || e.trim() ? "script" === (i = r).tag || "style" === i.tag ? e : sa(e) : f.length ? a ? "condense" === a && oa.test(e) ? "" : " " : o ? " " : "" : "") c || "condense" !== a || (e = e.replace(aa, " ")), !s && " " !== e && (u = function (e, t) {
            var n = t ? ho(t) : po;

            if (n.test(e)) {
              for (var r, i, o, a = [], s = [], c = n.lastIndex = 0; r = n.exec(e);) {
                (i = r.index) > c && (s.push(o = e.slice(c, i)), a.push(JSON.stringify(o)));
                var u = Ar(r[1].trim());
                a.push("_s(" + u + ")"), s.push({
                  "@binding": u
                }), c = i + r[0].length;
              }

              return c < e.length && (s.push(o = e.slice(c)), a.push(JSON.stringify(o))), {
                expression: a.join("+"),
                tokens: s
              };
            }
          }(e, Uo)) ? l = {
            type: 2,
            expression: u.expression,
            tokens: u.tokens,
            text: e
          } : " " === e && f.length && " " === f[f.length - 1].text || (l = {
            type: 3,
            text: e
          }), l && f.push(l);
        }
      },
      comment: function (e, t, n) {
        if (r) {
          var i = {
            type: 3,
            text: e,
            isComment: !0
          };
          r.children.push(i);
        }
      }
    }), n;
  }

  function fa(e, t) {
    var n, r;
    (r = Ir(n = e, "key")) && (n.key = r), e.plain = !e.key && !e.scopedSlots && !e.attrsList.length, function (e) {
      var t = Ir(e, "ref");
      t && (e.ref = t, e.refInFor = function (e) {
        var t = e;

        for (; t;) {
          if (void 0 !== t.for) return !0;
          t = t.parent;
        }

        return !1;
      }(e));
    }(e), function (e) {
      var t;
      "template" === e.tag ? (t = Fr(e, "scope"), e.slotScope = t || Fr(e, "slot-scope")) : (t = Fr(e, "slot-scope")) && (e.slotScope = t);
      var n = Ir(e, "slot");
      n && (e.slotTarget = '""' === n ? '"default"' : n, e.slotTargetDynamic = !(!e.attrsMap[":slot"] && !e.attrsMap["v-bind:slot"]), "template" === e.tag || e.slotScope || Nr(e, "slot", n, function (e, t) {
        return e.rawAttrsMap[":" + t] || e.rawAttrsMap["v-bind:" + t] || e.rawAttrsMap[t];
      }(e, "slot")));

      if ("template" === e.tag) {
        var r = Pr(e, ia);

        if (r) {
          var i = va(r),
              o = i.name,
              a = i.dynamic;
          e.slotTarget = o, e.slotTargetDynamic = a, e.slotScope = r.value || ca;
        }
      } else {
        var s = Pr(e, ia);

        if (s) {
          var c = e.scopedSlots || (e.scopedSlots = {}),
              u = va(s),
              l = u.name,
              f = u.dynamic,
              p = c[l] = ua("template", [], e);
          p.slotTarget = l, p.slotTargetDynamic = f, p.children = e.children.filter(function (e) {
            if (!e.slotScope) return e.parent = p, !0;
          }), p.slotScope = s.value || ca, e.children = [], e.plain = !1;
        }
      }
    }(e), function (e) {
      "slot" === e.tag && (e.slotName = Ir(e, "name"));
    }(e), function (e) {
      var t;
      (t = Ir(e, "is")) && (e.component = t);
      null != Fr(e, "inline-template") && (e.inlineTemplate = !0);
    }(e);

    for (var i = 0; i < zo.length; i++) e = zo[i](e, t) || e;

    return function (e) {
      var t,
          n,
          r,
          i,
          o,
          a,
          s,
          c,
          u = e.attrsList;

      for (t = 0, n = u.length; t < n; t++) if (r = i = u[t].name, o = u[t].value, Go.test(r)) {
        if (e.hasBindings = !0, (a = ha(r.replace(Go, ""))) && (r = r.replace(ra, "")), na.test(r)) r = r.replace(na, ""), o = Ar(o), (c = ea.test(r)) && (r = r.slice(1, -1)), a && (a.prop && !c && "innerHtml" === (r = b(r)) && (r = "innerHTML"), a.camel && !c && (r = b(r)), a.sync && (s = Br(o, "$event"), c ? Mr(e, '"update:"+(' + r + ")", s, null, !1, 0, u[t], !0) : (Mr(e, "update:" + b(r), s, null, !1, 0, u[t]), C(r) !== b(r) && Mr(e, "update:" + C(r), s, null, !1, 0, u[t])))), a && a.prop || !e.component && qo(e.tag, e.attrsMap.type, r) ? Er(e, r, o, u[t], c) : Nr(e, r, o, u[t], c);else if (Zo.test(r)) r = r.replace(Zo, ""), (c = ea.test(r)) && (r = r.slice(1, -1)), Mr(e, r, o, a, !1, 0, u[t], c);else {
          var l = (r = r.replace(Go, "")).match(ta),
              f = l && l[1];
          c = !1, f && (r = r.slice(0, -(f.length + 1)), ea.test(f) && (f = f.slice(1, -1), c = !0)), Dr(e, r, i, o, f, c, a, u[t]);
        }
      } else Nr(e, r, JSON.stringify(o), u[t]), !e.component && "muted" === r && qo(e.tag, e.attrsMap.type, r) && Er(e, r, "true", u[t]);
    }(e), e;
  }

  function pa(e) {
    var t;

    if (t = Fr(e, "v-for")) {
      var n = function (e) {
        var t = e.match(Xo);
        if (!t) return;
        var n = {};
        n.for = t[2].trim();
        var r = t[1].trim().replace(Qo, ""),
            i = r.match(Yo);
        i ? (n.alias = r.replace(Yo, "").trim(), n.iterator1 = i[1].trim(), i[2] && (n.iterator2 = i[2].trim())) : n.alias = r;
        return n;
      }(t);

      n && A(e, n);
    }
  }

  function da(e, t) {
    e.ifConditions || (e.ifConditions = []), e.ifConditions.push(t);
  }

  function va(e) {
    var t = e.name.replace(ia, "");
    return t || "#" !== e.name[0] && (t = "default"), ea.test(t) ? {
      name: t.slice(1, -1),
      dynamic: !0
    } : {
      name: '"' + t + '"',
      dynamic: !1
    };
  }

  function ha(e) {
    var t = e.match(ra);

    if (t) {
      var n = {};
      return t.forEach(function (e) {
        n[e.slice(1)] = !0;
      }), n;
    }
  }

  function ma(e) {
    for (var t = {}, n = 0, r = e.length; n < r; n++) t[e[n].name] = e[n].value;

    return t;
  }

  var ya = /^xmlns:NS\d+/,
      ga = /^NS\d+:/;

  function _a(e) {
    return ua(e.tag, e.attrsList.slice(), e.parent);
  }

  var ba = [mo, go, {
    preTransformNode: function (e, t) {
      if ("input" === e.tag) {
        var n,
            r = e.attrsMap;
        if (!r["v-model"]) return;

        if ((r[":type"] || r["v-bind:type"]) && (n = Ir(e, "type")), r.type || n || !r["v-bind"] || (n = "(" + r["v-bind"] + ").type"), n) {
          var i = Fr(e, "v-if", !0),
              o = i ? "&&(" + i + ")" : "",
              a = null != Fr(e, "v-else", !0),
              s = Fr(e, "v-else-if", !0),
              c = _a(e);

          pa(c), jr(c, "type", "checkbox"), fa(c, t), c.processed = !0, c.if = "(" + n + ")==='checkbox'" + o, da(c, {
            exp: c.if,
            block: c
          });

          var u = _a(e);

          Fr(u, "v-for", !0), jr(u, "type", "radio"), fa(u, t), da(c, {
            exp: "(" + n + ")==='radio'" + o,
            block: u
          });

          var l = _a(e);

          return Fr(l, "v-for", !0), jr(l, ":type", n), fa(l, t), da(c, {
            exp: i,
            block: l
          }), a ? c.else = !0 : s && (c.elseif = s), c;
        }
      }
    }
  }];
  var $a,
      wa,
      Ca = {
    expectHTML: !0,
    modules: ba,
    directives: {
      model: function (e, t, n) {
        var r = t.value,
            i = t.modifiers,
            o = e.tag,
            a = e.attrsMap.type;
        if (e.component) return Hr(e, r, i), !1;
        if ("select" === o) !function (e, t, n) {
          var r = 'var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ' + (n && n.number ? "_n(val)" : "val") + "});";
          r = r + " " + Br(t, "$event.target.multiple ? $$selectedVal : $$selectedVal[0]"), Mr(e, "change", r, null, !0);
        }(e, r, i);else if ("input" === o && "checkbox" === a) !function (e, t, n) {
          var r = n && n.number,
              i = Ir(e, "value") || "null",
              o = Ir(e, "true-value") || "true",
              a = Ir(e, "false-value") || "false";
          Er(e, "checked", "Array.isArray(" + t + ")?_i(" + t + "," + i + ")>-1" + ("true" === o ? ":(" + t + ")" : ":_q(" + t + "," + o + ")")), Mr(e, "change", "var $$a=" + t + ",$$el=$event.target,$$c=$$el.checked?(" + o + "):(" + a + ");if(Array.isArray($$a)){var $$v=" + (r ? "_n(" + i + ")" : i) + ",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(" + Br(t, "$$a.concat([$$v])") + ")}else{$$i>-1&&(" + Br(t, "$$a.slice(0,$$i).concat($$a.slice($$i+1))") + ")}}else{" + Br(t, "$$c") + "}", null, !0);
        }(e, r, i);else if ("input" === o && "radio" === a) !function (e, t, n) {
          var r = n && n.number,
              i = Ir(e, "value") || "null";
          Er(e, "checked", "_q(" + t + "," + (i = r ? "_n(" + i + ")" : i) + ")"), Mr(e, "change", Br(t, i), null, !0);
        }(e, r, i);else if ("input" === o || "textarea" === o) !function (e, t, n) {
          var r = e.attrsMap.type,
              i = n || {},
              o = i.lazy,
              a = i.number,
              s = i.trim,
              c = !o && "range" !== r,
              u = o ? "change" : "range" === r ? Wr : "input",
              l = "$event.target.value";
          s && (l = "$event.target.value.trim()"), a && (l = "_n(" + l + ")");
          var f = Br(t, l);
          c && (f = "if($event.target.composing)return;" + f), Er(e, "value", "(" + t + ")"), Mr(e, u, f, null, !0), (s || a) && Mr(e, "blur", "$forceUpdate()");
        }(e, r, i);else if (!F.isReservedTag(o)) return Hr(e, r, i), !1;
        return !0;
      },
      text: function (e, t) {
        t.value && Er(e, "textContent", "_s(" + t.value + ")", t);
      },
      html: function (e, t) {
        t.value && Er(e, "innerHTML", "_s(" + t.value + ")", t);
      }
    },
    isPreTag: function (e) {
      return "pre" === e;
    },
    isUnaryTag: bo,
    mustUseProp: jn,
    canBeLeftOpenTag: $o,
    isReservedTag: Wn,
    getTagNamespace: Zn,
    staticKeys: function (e) {
      return e.reduce(function (e, t) {
        return e.concat(t.staticKeys || []);
      }, []).join(",");
    }(ba)
  },
      xa = g(function (e) {
    return p("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap" + (e ? "," + e : ""));
  });

  function ka(e, t) {
    e && ($a = xa(t.staticKeys || ""), wa = t.isReservedTag || T, function e(t) {
      t.static = function (e) {
        if (2 === e.type) return !1;
        if (3 === e.type) return !0;
        return !(!e.pre && (e.hasBindings || e.if || e.for || d(e.tag) || !wa(e.tag) || function (e) {
          for (; e.parent;) {
            if ("template" !== (e = e.parent).tag) return !1;
            if (e.for) return !0;
          }

          return !1;
        }(e) || !Object.keys(e).every($a)));
      }(t);

      if (1 === t.type) {
        if (!wa(t.tag) && "slot" !== t.tag && null == t.attrsMap["inline-template"]) return;

        for (var n = 0, r = t.children.length; n < r; n++) {
          var i = t.children[n];
          e(i), i.static || (t.static = !1);
        }

        if (t.ifConditions) for (var o = 1, a = t.ifConditions.length; o < a; o++) {
          var s = t.ifConditions[o].block;
          e(s), s.static || (t.static = !1);
        }
      }
    }(e), function e(t, n) {
      if (1 === t.type) {
        if ((t.static || t.once) && (t.staticInFor = n), t.static && t.children.length && (1 !== t.children.length || 3 !== t.children[0].type)) return void (t.staticRoot = !0);
        if (t.staticRoot = !1, t.children) for (var r = 0, i = t.children.length; r < i; r++) e(t.children[r], n || !!t.for);
        if (t.ifConditions) for (var o = 1, a = t.ifConditions.length; o < a; o++) e(t.ifConditions[o].block, n);
      }
    }(e, !1));
  }

  var Aa = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,
      Oa = /\([^)]*?\);*$/,
      Sa = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,
      Ta = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    delete: [8, 46]
  },
      Ea = {
    esc: ["Esc", "Escape"],
    tab: "Tab",
    enter: "Enter",
    space: [" ", "Spacebar"],
    up: ["Up", "ArrowUp"],
    left: ["Left", "ArrowLeft"],
    right: ["Right", "ArrowRight"],
    down: ["Down", "ArrowDown"],
    delete: ["Backspace", "Delete", "Del"]
  },
      Na = function (e) {
    return "if(" + e + ")return null;";
  },
      ja = {
    stop: "$event.stopPropagation();",
    prevent: "$event.preventDefault();",
    self: Na("$event.target !== $event.currentTarget"),
    ctrl: Na("!$event.ctrlKey"),
    shift: Na("!$event.shiftKey"),
    alt: Na("!$event.altKey"),
    meta: Na("!$event.metaKey"),
    left: Na("'button' in $event && $event.button !== 0"),
    middle: Na("'button' in $event && $event.button !== 1"),
    right: Na("'button' in $event && $event.button !== 2")
  };

  function Da(e, t) {
    var n = t ? "nativeOn:" : "on:",
        r = "",
        i = "";

    for (var o in e) {
      var a = La(e[o]);
      e[o] && e[o].dynamic ? i += o + "," + a + "," : r += '"' + o + '":' + a + ",";
    }

    return r = "{" + r.slice(0, -1) + "}", i ? n + "_d(" + r + ",[" + i.slice(0, -1) + "])" : n + r;
  }

  function La(e) {
    if (!e) return "function(){}";
    if (Array.isArray(e)) return "[" + e.map(function (e) {
      return La(e);
    }).join(",") + "]";
    var t = Sa.test(e.value),
        n = Aa.test(e.value),
        r = Sa.test(e.value.replace(Oa, ""));

    if (e.modifiers) {
      var i = "",
          o = "",
          a = [];

      for (var s in e.modifiers) if (ja[s]) o += ja[s], Ta[s] && a.push(s);else if ("exact" === s) {
        var c = e.modifiers;
        o += Na(["ctrl", "shift", "alt", "meta"].filter(function (e) {
          return !c[e];
        }).map(function (e) {
          return "$event." + e + "Key";
        }).join("||"));
      } else a.push(s);

      return a.length && (i += function (e) {
        return "if(!$event.type.indexOf('key')&&" + e.map(Ma).join("&&") + ")return null;";
      }(a)), o && (i += o), "function($event){" + i + (t ? "return " + e.value + "($event)" : n ? "return (" + e.value + ")($event)" : r ? "return " + e.value : e.value) + "}";
    }

    return t || n ? e.value : "function($event){" + (r ? "return " + e.value : e.value) + "}";
  }

  function Ma(e) {
    var t = parseInt(e, 10);
    if (t) return "$event.keyCode!==" + t;
    var n = Ta[e],
        r = Ea[e];
    return "_k($event.keyCode," + JSON.stringify(e) + "," + JSON.stringify(n) + ",$event.key," + JSON.stringify(r) + ")";
  }

  var Ia = {
    on: function (e, t) {
      e.wrapListeners = function (e) {
        return "_g(" + e + "," + t.value + ")";
      };
    },
    bind: function (e, t) {
      e.wrapData = function (n) {
        return "_b(" + n + ",'" + e.tag + "'," + t.value + "," + (t.modifiers && t.modifiers.prop ? "true" : "false") + (t.modifiers && t.modifiers.sync ? ",true" : "") + ")";
      };
    },
    cloak: S
  },
      Fa = function (e) {
    this.options = e, this.warn = e.warn || Sr, this.transforms = Tr(e.modules, "transformCode"), this.dataGenFns = Tr(e.modules, "genData"), this.directives = A(A({}, Ia), e.directives);
    var t = e.isReservedTag || T;
    this.maybeComponent = function (e) {
      return !!e.component || !t(e.tag);
    }, this.onceId = 0, this.staticRenderFns = [], this.pre = !1;
  };

  function Pa(e, t) {
    var n = new Fa(t);
    return {
      render: "with(this){return " + (e ? Ra(e, n) : '_c("div")') + "}",
      staticRenderFns: n.staticRenderFns
    };
  }

  function Ra(e, t) {
    if (e.parent && (e.pre = e.pre || e.parent.pre), e.staticRoot && !e.staticProcessed) return Ha(e, t);
    if (e.once && !e.onceProcessed) return Ba(e, t);
    if (e.for && !e.forProcessed) return za(e, t);
    if (e.if && !e.ifProcessed) return Ua(e, t);

    if ("template" !== e.tag || e.slotTarget || t.pre) {
      if ("slot" === e.tag) return function (e, t) {
        var n = e.slotName || '"default"',
            r = qa(e, t),
            i = "_t(" + n + (r ? "," + r : ""),
            o = e.attrs || e.dynamicAttrs ? Ga((e.attrs || []).concat(e.dynamicAttrs || []).map(function (e) {
          return {
            name: b(e.name),
            value: e.value,
            dynamic: e.dynamic
          };
        })) : null,
            a = e.attrsMap["v-bind"];
        !o && !a || r || (i += ",null");
        o && (i += "," + o);
        a && (i += (o ? "" : ",null") + "," + a);
        return i + ")";
      }(e, t);
      var n;
      if (e.component) n = function (e, t, n) {
        var r = t.inlineTemplate ? null : qa(t, n, !0);
        return "_c(" + e + "," + Va(t, n) + (r ? "," + r : "") + ")";
      }(e.component, e, t);else {
        var r;
        (!e.plain || e.pre && t.maybeComponent(e)) && (r = Va(e, t));
        var i = e.inlineTemplate ? null : qa(e, t, !0);
        n = "_c('" + e.tag + "'" + (r ? "," + r : "") + (i ? "," + i : "") + ")";
      }

      for (var o = 0; o < t.transforms.length; o++) n = t.transforms[o](e, n);

      return n;
    }

    return qa(e, t) || "void 0";
  }

  function Ha(e, t) {
    e.staticProcessed = !0;
    var n = t.pre;
    return e.pre && (t.pre = e.pre), t.staticRenderFns.push("with(this){return " + Ra(e, t) + "}"), t.pre = n, "_m(" + (t.staticRenderFns.length - 1) + (e.staticInFor ? ",true" : "") + ")";
  }

  function Ba(e, t) {
    if (e.onceProcessed = !0, e.if && !e.ifProcessed) return Ua(e, t);

    if (e.staticInFor) {
      for (var n = "", r = e.parent; r;) {
        if (r.for) {
          n = r.key;
          break;
        }

        r = r.parent;
      }

      return n ? "_o(" + Ra(e, t) + "," + t.onceId++ + "," + n + ")" : Ra(e, t);
    }

    return Ha(e, t);
  }

  function Ua(e, t, n, r) {
    return e.ifProcessed = !0, function e(t, n, r, i) {
      if (!t.length) return i || "_e()";
      var o = t.shift();
      return o.exp ? "(" + o.exp + ")?" + a(o.block) + ":" + e(t, n, r, i) : "" + a(o.block);

      function a(e) {
        return r ? r(e, n) : e.once ? Ba(e, n) : Ra(e, n);
      }
    }(e.ifConditions.slice(), t, n, r);
  }

  function za(e, t, n, r) {
    var i = e.for,
        o = e.alias,
        a = e.iterator1 ? "," + e.iterator1 : "",
        s = e.iterator2 ? "," + e.iterator2 : "";
    return e.forProcessed = !0, (r || "_l") + "((" + i + "),function(" + o + a + s + "){return " + (n || Ra)(e, t) + "})";
  }

  function Va(e, t) {
    var n = "{",
        r = function (e, t) {
      var n = e.directives;
      if (!n) return;
      var r,
          i,
          o,
          a,
          s = "directives:[",
          c = !1;

      for (r = 0, i = n.length; r < i; r++) {
        o = n[r], a = !0;
        var u = t.directives[o.name];
        u && (a = !!u(e, o, t.warn)), a && (c = !0, s += '{name:"' + o.name + '",rawName:"' + o.rawName + '"' + (o.value ? ",value:(" + o.value + "),expression:" + JSON.stringify(o.value) : "") + (o.arg ? ",arg:" + (o.isDynamicArg ? o.arg : '"' + o.arg + '"') : "") + (o.modifiers ? ",modifiers:" + JSON.stringify(o.modifiers) : "") + "},");
      }

      if (c) return s.slice(0, -1) + "]";
    }(e, t);

    r && (n += r + ","), e.key && (n += "key:" + e.key + ","), e.ref && (n += "ref:" + e.ref + ","), e.refInFor && (n += "refInFor:true,"), e.pre && (n += "pre:true,"), e.component && (n += 'tag:"' + e.tag + '",');

    for (var i = 0; i < t.dataGenFns.length; i++) n += t.dataGenFns[i](e);

    if (e.attrs && (n += "attrs:" + Ga(e.attrs) + ","), e.props && (n += "domProps:" + Ga(e.props) + ","), e.events && (n += Da(e.events, !1) + ","), e.nativeEvents && (n += Da(e.nativeEvents, !0) + ","), e.slotTarget && !e.slotScope && (n += "slot:" + e.slotTarget + ","), e.scopedSlots && (n += function (e, t, n) {
      var r = e.for || Object.keys(t).some(function (e) {
        var n = t[e];
        return n.slotTargetDynamic || n.if || n.for || Ka(n);
      }),
          i = !!e.if;
      if (!r) for (var o = e.parent; o;) {
        if (o.slotScope && o.slotScope !== ca || o.for) {
          r = !0;
          break;
        }

        o.if && (i = !0), o = o.parent;
      }
      var a = Object.keys(t).map(function (e) {
        return Ja(t[e], n);
      }).join(",");
      return "scopedSlots:_u([" + a + "]" + (r ? ",null,true" : "") + (!r && i ? ",null,false," + function (e) {
        var t = 5381,
            n = e.length;

        for (; n;) t = 33 * t ^ e.charCodeAt(--n);

        return t >>> 0;
      }(a) : "") + ")";
    }(e, e.scopedSlots, t) + ","), e.model && (n += "model:{value:" + e.model.value + ",callback:" + e.model.callback + ",expression:" + e.model.expression + "},"), e.inlineTemplate) {
      var o = function (e, t) {
        var n = e.children[0];

        if (n && 1 === n.type) {
          var r = Pa(n, t.options);
          return "inlineTemplate:{render:function(){" + r.render + "},staticRenderFns:[" + r.staticRenderFns.map(function (e) {
            return "function(){" + e + "}";
          }).join(",") + "]}";
        }
      }(e, t);

      o && (n += o + ",");
    }

    return n = n.replace(/,$/, "") + "}", e.dynamicAttrs && (n = "_b(" + n + ',"' + e.tag + '",' + Ga(e.dynamicAttrs) + ")"), e.wrapData && (n = e.wrapData(n)), e.wrapListeners && (n = e.wrapListeners(n)), n;
  }

  function Ka(e) {
    return 1 === e.type && ("slot" === e.tag || e.children.some(Ka));
  }

  function Ja(e, t) {
    var n = e.attrsMap["slot-scope"];
    if (e.if && !e.ifProcessed && !n) return Ua(e, t, Ja, "null");
    if (e.for && !e.forProcessed) return za(e, t, Ja);
    var r = e.slotScope === ca ? "" : String(e.slotScope),
        i = "function(" + r + "){return " + ("template" === e.tag ? e.if && n ? "(" + e.if + ")?" + (qa(e, t) || "undefined") + ":undefined" : qa(e, t) || "undefined" : Ra(e, t)) + "}",
        o = r ? "" : ",proxy:true";
    return "{key:" + (e.slotTarget || '"default"') + ",fn:" + i + o + "}";
  }

  function qa(e, t, n, r, i) {
    var o = e.children;

    if (o.length) {
      var a = o[0];

      if (1 === o.length && a.for && "template" !== a.tag && "slot" !== a.tag) {
        var s = n ? t.maybeComponent(a) ? ",1" : ",0" : "";
        return "" + (r || Ra)(a, t) + s;
      }

      var c = n ? function (e, t) {
        for (var n = 0, r = 0; r < e.length; r++) {
          var i = e[r];

          if (1 === i.type) {
            if (Wa(i) || i.ifConditions && i.ifConditions.some(function (e) {
              return Wa(e.block);
            })) {
              n = 2;
              break;
            }

            (t(i) || i.ifConditions && i.ifConditions.some(function (e) {
              return t(e.block);
            })) && (n = 1);
          }
        }

        return n;
      }(o, t.maybeComponent) : 0,
          u = i || Za;
      return "[" + o.map(function (e) {
        return u(e, t);
      }).join(",") + "]" + (c ? "," + c : "");
    }
  }

  function Wa(e) {
    return void 0 !== e.for || "template" === e.tag || "slot" === e.tag;
  }

  function Za(e, t) {
    return 1 === e.type ? Ra(e, t) : 3 === e.type && e.isComment ? (r = e, "_e(" + JSON.stringify(r.text) + ")") : "_v(" + (2 === (n = e).type ? n.expression : Xa(JSON.stringify(n.text))) + ")";
    var n, r;
  }

  function Ga(e) {
    for (var t = "", n = "", r = 0; r < e.length; r++) {
      var i = e[r],
          o = Xa(i.value);
      i.dynamic ? n += i.name + "," + o + "," : t += '"' + i.name + '":' + o + ",";
    }

    return t = "{" + t.slice(0, -1) + "}", n ? "_d(" + t + ",[" + n.slice(0, -1) + "])" : t;
  }

  function Xa(e) {
    return e.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }

  new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b") + "\\b");

  function Ya(e, t) {
    try {
      return new Function(e);
    } catch (n) {
      return t.push({
        err: n,
        code: e
      }), S;
    }
  }

  function Qa(e) {
    var t = Object.create(null);
    return function (n, r, i) {
      (r = A({}, r)).warn;
      delete r.warn;
      var o = r.delimiters ? String(r.delimiters) + n : n;
      if (t[o]) return t[o];
      var a = e(n, r),
          s = {},
          c = [];
      return s.render = Ya(a.render, c), s.staticRenderFns = a.staticRenderFns.map(function (e) {
        return Ya(e, c);
      }), t[o] = s;
    };
  }

  var es,
      ts,
      ns = (es = function (e, t) {
    var n = la(e.trim(), t);
    !1 !== t.optimize && ka(n, t);
    var r = Pa(n, t);
    return {
      ast: n,
      render: r.render,
      staticRenderFns: r.staticRenderFns
    };
  }, function (e) {
    function t(t, n) {
      var r = Object.create(e),
          i = [],
          o = [];
      if (n) for (var a in n.modules && (r.modules = (e.modules || []).concat(n.modules)), n.directives && (r.directives = A(Object.create(e.directives || null), n.directives)), n) "modules" !== a && "directives" !== a && (r[a] = n[a]);

      r.warn = function (e, t, n) {
        (n ? o : i).push(e);
      };

      var s = es(t.trim(), r);
      return s.errors = i, s.tips = o, s;
    }

    return {
      compile: t,
      compileToFunctions: Qa(t)
    };
  })(Ca),
      rs = (ns.compile, ns.compileToFunctions);

  function is(e) {
    return (ts = ts || document.createElement("div")).innerHTML = e ? '<a href="\n"/>' : '<div a="\n"/>', ts.innerHTML.indexOf("&#10;") > 0;
  }

  var os = !!z && is(!1),
      as = !!z && is(!0),
      ss = g(function (e) {
    var t = Yn(e);
    return t && t.innerHTML;
  }),
      cs = wn.prototype.$mount;
  return wn.prototype.$mount = function (e, t) {
    if ((e = e && Yn(e)) === document.body || e === document.documentElement) return this;
    var n = this.$options;

    if (!n.render) {
      var r = n.template;
      if (r) {
        if ("string" == typeof r) "#" === r.charAt(0) && (r = ss(r));else {
          if (!r.nodeType) return this;
          r = r.innerHTML;
        }
      } else e && (r = function (e) {
        if (e.outerHTML) return e.outerHTML;
        var t = document.createElement("div");
        return t.appendChild(e.cloneNode(!0)), t.innerHTML;
      }(e));

      if (r) {
        var i = rs(r, {
          outputSourceRange: !1,
          shouldDecodeNewlines: os,
          shouldDecodeNewlinesForHref: as,
          delimiters: n.delimiters,
          comments: n.comments
        }, this),
            o = i.render,
            a = i.staticRenderFns;
        n.render = o, n.staticRenderFns = a;
      }
    }

    return cs.call(this, e, t);
  }, wn.compile = rs, wn;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(17).setImmediate))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Vue) {module.exports = Vue.component('customMenu', {
  template: `
    <div class="row-menu col-md-12 d-flex">
        <div class="col-md-2">
            <h1>
                <router-link to='/home'>
                    <h1>
                        <svg xmlns="http://www.w3.org/2000/svg" width="136" height="26" viewBox="0 0 136 26">
                            <g fill="none" fill-rule="evenodd">
                                <path fill="#3CB4E7" d="M24.86 25.146c-4.519 0-8.195-3.575-8.195-7.969s3.676-7.97 8.195-7.97c4.518 0 8.194 3.576 8.194 7.97s-3.676 7.97-8.194 7.97zm0-12.59c-2.62 0-4.751 2.074-4.751 4.621 0 2.547 2.132 4.62 4.75 4.62 2.622 0 4.752-2.073 4.752-4.62s-2.132-4.62-4.751-4.62zM8.195 25.146C3.676 25.146 0 21.571 0 17.177s3.676-7.97 8.195-7.97c2.478 0 4.798 1.076 6.363 2.95.6.72.488 1.774-.25 2.356a1.755 1.755 0 0 1-2.422-.244 4.787 4.787 0 0 0-3.69-1.711c-2.62 0-4.751 2.073-4.751 4.62 0 2.548 2.131 4.62 4.75 4.62a4.79 4.79 0 0 0 3.691-1.71 1.754 1.754 0 0 1 2.421-.245c.739.583.85 1.638.251 2.356-1.565 1.872-3.885 2.947-6.363 2.947zM42.97 9.208c-4.518 0-8.194 3.575-8.194 7.969v6.295c0 .924.771 1.674 1.722 1.674.95 0 1.721-.749 1.721-1.674v-6.295c0-2.547 2.132-4.62 4.751-4.62 2.62 0 4.751 2.073 4.751 4.62v6.295c0 .924.772 1.674 1.722 1.674.952 0 1.722-.749 1.722-1.674v-6.295c0-4.394-3.676-7.97-8.195-7.97zM100.846 9.208c-.887 0-1.617.652-1.712 1.49a8.302 8.302 0 0 0-4.762-1.49c-4.52 0-8.195 3.575-8.195 7.969s3.676 7.97 8.195 7.97c1.775 0 3.42-.554 4.762-1.491.095.838.825 1.49 1.712 1.49.95 0 1.721-.749 1.721-1.674v-12.59c0-.925-.771-1.674-1.721-1.674zm-6.473 12.59c-2.62 0-4.751-2.074-4.751-4.621 0-2.547 2.131-4.62 4.75-4.62 2.62 0 4.752 2.073 4.752 4.62 0 2.549-2.132 4.62-4.751 4.62zM79.912 17.177l4.18-5.2a1.643 1.643 0 0 0-.296-2.351 1.754 1.754 0 0 0-2.417.287l-3.653 4.544-3.652-4.544a1.753 1.753 0 0 0-2.416-.287 1.643 1.643 0 0 0-.295 2.35l4.18 5.201-4.18 5.2a1.645 1.645 0 0 0 .295 2.351c.314.24.69.356 1.06.356.51 0 1.018-.221 1.357-.643l3.653-4.544 3.652 4.544c.34.423.845.643 1.358.643.37 0 .744-.117 1.059-.356.75-.568.882-1.622.296-2.35l-4.181-5.201zM61.08 9.208c-4.518 0-8.194 3.575-8.194 7.969s3.676 7.97 8.195 7.97h4.098c.95 0 1.721-.751 1.721-1.675s-.771-1.674-1.721-1.674H61.08c-2.012 0-3.735-1.225-4.427-2.947h10.9c.95 0 1.721-.749 1.721-1.674-.001-4.394-3.676-7.97-8.194-7.97zm-4.428 6.295c.69-1.723 2.415-2.946 4.429-2.946 2.013 0 3.738 1.223 4.429 2.946h-8.858zM113.812 24.126s.002 0 0 0c-.002-.016-.009-.032-.013-.048a.128.128 0 0 1-.005-.022c-.408-1.562-1.67-2.791-3.275-3.191-.021-.007-.044-.012-.065-.018a.886.886 0 0 0-.202-.025.849.849 0 0 0-.861.838v1.81c0 .925.77 1.675 1.722 1.675h1.86c.476 0 .861-.374.861-.837a.762.762 0 0 0-.022-.182z"/>
                                <path fill="#EF4056" d="M133.526 7.551h-6.043V1.674c0-.924-.77-1.674-1.721-1.674h-6.886c-.95 0-1.722.749-1.722 1.674v5.877h-6.043c-.95 0-1.722.75-1.722 1.675v2.58c0 .444.357.807.805.835v.001c6.474.389 11.654 5.426 12.053 11.722h.003a.85.85 0 0 0 .858.782h2.654c.95 0 1.721-.749 1.721-1.674v-5.877h6.043c.95 0 1.722-.749 1.722-1.674V9.224c0-.924-.771-1.673-1.722-1.673z"/>
                                <path fill="#3CB4E7" d="M119.456 24.222v-.005c-.45-4.684-4.28-8.413-9.094-8.859l-.037-.004c-.005 0-.01 0-.017-.002l-.004.001a.849.849 0 0 0-.913.835v1.025c0 .432.336.787.767.832l.003.001c3.433.35 6.163 2.999 6.528 6.336a.85.85 0 0 0 .857.763h1.054c.476 0 .86-.374.86-.837 0-.028-.002-.056-.004-.086z"/>
                            </g>
                        </svg>
                    </h1>
                </router-link>
            </h1>
        </div>
        <div class="col-md-10">
            <ul class="nav">
                <li>
                    <router-link to='/listMedicalAppointment'>Consultas</router-link>
                </li>
                <li>
                    <router-link to='/enrollMedicalAppointment'>Cadastrar Consulta</router-link>
                </li>
                <li>
                    <router-link to='/' v-on:click="resetData">Sair</router-link>
                </li>

            </ul>    
        </div>
    </div>
    `,
  methods: {
    resetData: function () {
      console.log('reset data');
    }
  }
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 3 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Vue) {module.exports = Vue.component('login', {
  template: `
    <div class="row">
        <div class='col-md-4'></div>
        <div class='col-md-4 container-login'>
            <div>
            
                <h1>
                    <svg xmlns="http://www.w3.org/2000/svg" width="136" height="26" viewBox="0 0 136 26">
                        <g fill="none" fill-rule="evenodd">
                            <path fill="#3CB4E7" d="M24.86 25.146c-4.519 0-8.195-3.575-8.195-7.969s3.676-7.97 8.195-7.97c4.518 0 8.194 3.576 8.194 7.97s-3.676 7.97-8.194 7.97zm0-12.59c-2.62 0-4.751 2.074-4.751 4.621 0 2.547 2.132 4.62 4.75 4.62 2.622 0 4.752-2.073 4.752-4.62s-2.132-4.62-4.751-4.62zM8.195 25.146C3.676 25.146 0 21.571 0 17.177s3.676-7.97 8.195-7.97c2.478 0 4.798 1.076 6.363 2.95.6.72.488 1.774-.25 2.356a1.755 1.755 0 0 1-2.422-.244 4.787 4.787 0 0 0-3.69-1.711c-2.62 0-4.751 2.073-4.751 4.62 0 2.548 2.131 4.62 4.75 4.62a4.79 4.79 0 0 0 3.691-1.71 1.754 1.754 0 0 1 2.421-.245c.739.583.85 1.638.251 2.356-1.565 1.872-3.885 2.947-6.363 2.947zM42.97 9.208c-4.518 0-8.194 3.575-8.194 7.969v6.295c0 .924.771 1.674 1.722 1.674.95 0 1.721-.749 1.721-1.674v-6.295c0-2.547 2.132-4.62 4.751-4.62 2.62 0 4.751 2.073 4.751 4.62v6.295c0 .924.772 1.674 1.722 1.674.952 0 1.722-.749 1.722-1.674v-6.295c0-4.394-3.676-7.97-8.195-7.97zM100.846 9.208c-.887 0-1.617.652-1.712 1.49a8.302 8.302 0 0 0-4.762-1.49c-4.52 0-8.195 3.575-8.195 7.969s3.676 7.97 8.195 7.97c1.775 0 3.42-.554 4.762-1.491.095.838.825 1.49 1.712 1.49.95 0 1.721-.749 1.721-1.674v-12.59c0-.925-.771-1.674-1.721-1.674zm-6.473 12.59c-2.62 0-4.751-2.074-4.751-4.621 0-2.547 2.131-4.62 4.75-4.62 2.62 0 4.752 2.073 4.752 4.62 0 2.549-2.132 4.62-4.751 4.62zM79.912 17.177l4.18-5.2a1.643 1.643 0 0 0-.296-2.351 1.754 1.754 0 0 0-2.417.287l-3.653 4.544-3.652-4.544a1.753 1.753 0 0 0-2.416-.287 1.643 1.643 0 0 0-.295 2.35l4.18 5.201-4.18 5.2a1.645 1.645 0 0 0 .295 2.351c.314.24.69.356 1.06.356.51 0 1.018-.221 1.357-.643l3.653-4.544 3.652 4.544c.34.423.845.643 1.358.643.37 0 .744-.117 1.059-.356.75-.568.882-1.622.296-2.35l-4.181-5.201zM61.08 9.208c-4.518 0-8.194 3.575-8.194 7.969s3.676 7.97 8.195 7.97h4.098c.95 0 1.721-.751 1.721-1.675s-.771-1.674-1.721-1.674H61.08c-2.012 0-3.735-1.225-4.427-2.947h10.9c.95 0 1.721-.749 1.721-1.674-.001-4.394-3.676-7.97-8.194-7.97zm-4.428 6.295c.69-1.723 2.415-2.946 4.429-2.946 2.013 0 3.738 1.223 4.429 2.946h-8.858zM113.812 24.126s.002 0 0 0c-.002-.016-.009-.032-.013-.048a.128.128 0 0 1-.005-.022c-.408-1.562-1.67-2.791-3.275-3.191-.021-.007-.044-.012-.065-.018a.886.886 0 0 0-.202-.025.849.849 0 0 0-.861.838v1.81c0 .925.77 1.675 1.722 1.675h1.86c.476 0 .861-.374.861-.837a.762.762 0 0 0-.022-.182z"/>
                            <path fill="#EF4056" d="M133.526 7.551h-6.043V1.674c0-.924-.77-1.674-1.721-1.674h-6.886c-.95 0-1.722.749-1.722 1.674v5.877h-6.043c-.95 0-1.722.75-1.722 1.675v2.58c0 .444.357.807.805.835v.001c6.474.389 11.654 5.426 12.053 11.722h.003a.85.85 0 0 0 .858.782h2.654c.95 0 1.721-.749 1.721-1.674v-5.877h6.043c.95 0 1.722-.749 1.722-1.674V9.224c0-.924-.771-1.673-1.722-1.673z"/>
                            <path fill="#3CB4E7" d="M119.456 24.222v-.005c-.45-4.684-4.28-8.413-9.094-8.859l-.037-.004c-.005 0-.01 0-.017-.002l-.004.001a.849.849 0 0 0-.913.835v1.025c0 .432.336.787.767.832l.003.001c3.433.35 6.163 2.999 6.528 6.336a.85.85 0 0 0 .857.763h1.054c.476 0 .86-.374.86-.837 0-.028-.002-.056-.004-.086z"/>
                        </g>
                    </svg>
                </h1>
                <form>
                    <div class="form-group form-login">
                        <fieldset>
                            <legend>Área de login</legend>
                            <label for="input-login">Login<span class="required"></span>:</label>
                            <input :class="{'errorField': submit && !validation.email}" type="text" id="input-login" name="input-login" class="form-control" placeholder="Ex: conexa@conexasaude.com.br" v-model="form.email"/>
                            <span class="error" v-if="submit && !validation.email">Preenhcer com um e-mail válido.</span>
                            <br>
                            <br>
                            <label for="input-password" >Senha<span class="required"></span>:</label>
                            <input :class="{'errorField': submit && !validation.password}"  type="password" id="input-password" name="input-password" class="form-control"  v-model="form.password"/>
                            <span class="error" v-if="submit && !validation.password">Preenhcer com uma senha válida.</span>
                            <br>
                            <br>
                            <p>Itens com * são obrigatórios</p>
                            <input type="submit" class="btn btn-primary"  value="Enviar" v-on:click.prevent="login"/> 
                            <br>
                            <div class="alert alert-danger" role="alert" v-if="error">
                                Não foi possível realizar o login
                            </div>
                        </fieldset>
                    </div>
                </form>
            </div>
        </div>
        <div class='col-md-4'></div>
    </div>
    `,
  mixins: [__webpack_require__(6)],
  data: function () {
    return {
      form: {
        password: '',
        email: ''
      },
      error: false,
      submit: false
    };
  },
  computed: {
    validation: function () {
      return {
        email: !!this.form.email.trim(),
        password: !!this.form.password.trim()
      };
    }
  },
  methods: {
    login: function () {
      this.submit = true;

      if (this.isValid) {
        const obj = JSON.stringify(this.form);
        this.$root.resquestLogin(obj, this.showErrorLogin);
      }
    },
    showErrorLogin: function () {
      this.error = true;
    }
  }
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = {
  computed: {
    isValid: function () {
      var self = this;
      var validation = self.validation;

      if (typeof self.validation === 'object') {
        return Object.keys(validation).every(function (key) {
          return validation[key];
        });
      }
    }
  },
  mounted: function () {
    var self = this;
    /* FOCUS FIRST FIELD */

    if (self.$el.localName !== undefined) {
      if (self.$el.querySelector('input') !== null && !self.$el.querySelector('input').dataset.hasOwnProperty('autofocus')) {
        self.$el.querySelector('input').focus();
      }
    }
  }
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(25);

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(0);

var normalizeHeaderName = __webpack_require__(30);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(12);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(12);
  }

  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        /* Ignore */
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

var settle = __webpack_require__(31);

var cookies = __webpack_require__(33);

var buildURL = __webpack_require__(9);

var buildFullPath = __webpack_require__(34);

var parseHeaders = __webpack_require__(37);

var isURLSameOrigin = __webpack_require__(38);

var createError = __webpack_require__(13);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout; // Listen for ready state

    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      } // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request


      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }; // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(32);
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }

    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });
  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils.forEach(otherKeys, mergeDeepProperties);
  return config;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Vue, VueResource) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;const {
  default: VueRouter
} = __webpack_require__(21);

__webpack_require__(22);

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
  'use strict';

  Vue.use(VueResource);
  Vue.use(VueRouter);
  Vue.http.options.emulateJSON = true;
  Vue.http.options.emulateHTTP = true;
  const components = [__webpack_require__(5)];
  const mixins = [__webpack_require__(23), __webpack_require__(24), __webpack_require__(41)];

  const routes = __webpack_require__(42);

  const router = new VueRouter({
    routes
  });
  new Vue({
    el: '#app',
    mixins: mixins,
    components: components,
    router: router
  });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(19)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(18); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function (handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function (event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function (handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function (handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function (handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function (handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(4)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * vue-resource v1.5.1
 * https://github.com/pagekit/vue-resource
 * Released under the MIT License.
 */
!function (t, e) {
   true ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.VueResource = e();
}(this, function () {
  "use strict";

  function u(t) {
    this.state = 2, this.value = void 0, this.deferred = [];
    var e = this;

    try {
      t(function (t) {
        e.resolve(t);
      }, function (t) {
        e.reject(t);
      });
    } catch (t) {
      e.reject(t);
    }
  }

  u.reject = function (n) {
    return new u(function (t, e) {
      e(n);
    });
  }, u.resolve = function (n) {
    return new u(function (t, e) {
      t(n);
    });
  }, u.all = function (s) {
    return new u(function (n, t) {
      var o = 0,
          r = [];

      function e(e) {
        return function (t) {
          r[e] = t, (o += 1) === s.length && n(r);
        };
      }

      0 === s.length && n(r);

      for (var i = 0; i < s.length; i += 1) u.resolve(s[i]).then(e(i), t);
    });
  }, u.race = function (o) {
    return new u(function (t, e) {
      for (var n = 0; n < o.length; n += 1) u.resolve(o[n]).then(t, e);
    });
  };
  var t = u.prototype;

  function c(t, e) {
    t instanceof Promise ? this.promise = t : this.promise = new Promise(t.bind(e)), this.context = e;
  }

  t.resolve = function (t) {
    var e = this;

    if (2 === e.state) {
      if (t === e) throw new TypeError("Promise settled with itself.");
      var n = !1;

      try {
        var o = t && t.then;
        if (null !== t && "object" == typeof t && "function" == typeof o) return void o.call(t, function (t) {
          n || e.resolve(t), n = !0;
        }, function (t) {
          n || e.reject(t), n = !0;
        });
      } catch (t) {
        return void (n || e.reject(t));
      }

      e.state = 0, e.value = t, e.notify();
    }
  }, t.reject = function (t) {
    var e = this;

    if (2 === e.state) {
      if (t === e) throw new TypeError("Promise settled with itself.");
      e.state = 1, e.value = t, e.notify();
    }
  }, t.notify = function () {
    var t,
        i = this;
    r(function () {
      if (2 !== i.state) for (; i.deferred.length;) {
        var t = i.deferred.shift(),
            e = t[0],
            n = t[1],
            o = t[2],
            r = t[3];

        try {
          0 === i.state ? o("function" == typeof e ? e.call(void 0, i.value) : i.value) : 1 === i.state && ("function" == typeof n ? o(n.call(void 0, i.value)) : r(i.value));
        } catch (t) {
          r(t);
        }
      }
    }, t);
  }, t.then = function (n, o) {
    var r = this;
    return new u(function (t, e) {
      r.deferred.push([n, o, t, e]), r.notify();
    });
  }, t.catch = function (t) {
    return this.then(void 0, t);
  }, "undefined" == typeof Promise && (window.Promise = u), c.all = function (t, e) {
    return new c(Promise.all(t), e);
  }, c.resolve = function (t, e) {
    return new c(Promise.resolve(t), e);
  }, c.reject = function (t, e) {
    return new c(Promise.reject(t), e);
  }, c.race = function (t, e) {
    return new c(Promise.race(t), e);
  };
  var e = c.prototype;
  e.bind = function (t) {
    return this.context = t, this;
  }, e.then = function (t, e) {
    return t && t.bind && this.context && (t = t.bind(this.context)), e && e.bind && this.context && (e = e.bind(this.context)), new c(this.promise.then(t, e), this.context);
  }, e.catch = function (t) {
    return t && t.bind && this.context && (t = t.bind(this.context)), new c(this.promise.catch(t), this.context);
  }, e.finally = function (e) {
    return this.then(function (t) {
      return e.call(this), t;
    }, function (t) {
      return e.call(this), Promise.reject(t);
    });
  };
  var r,
      i = {}.hasOwnProperty,
      o = [].slice,
      a = !1,
      s = "undefined" != typeof window;

  function f(t) {
    return t ? t.replace(/^\s*|\s*$/g, "") : "";
  }

  function p(t) {
    return t ? t.toLowerCase() : "";
  }

  var h = Array.isArray;

  function d(t) {
    return "string" == typeof t;
  }

  function l(t) {
    return "function" == typeof t;
  }

  function m(t) {
    return null !== t && "object" == typeof t;
  }

  function y(t) {
    return m(t) && Object.getPrototypeOf(t) == Object.prototype;
  }

  function v(t, e, n) {
    var o = c.resolve(t);
    return arguments.length < 2 ? o : o.then(e, n);
  }

  function b(t, e, n) {
    return l(n = n || {}) && (n = n.call(e)), T(t.bind({
      $vm: e,
      $options: n
    }), t, {
      $options: n
    });
  }

  function g(t, e) {
    var n, o;
    if (h(t)) for (n = 0; n < t.length; n++) e.call(t[n], t[n], n);else if (m(t)) for (o in t) i.call(t, o) && e.call(t[o], t[o], o);
    return t;
  }

  var w = Object.assign || function (e) {
    return o.call(arguments, 1).forEach(function (t) {
      x(e, t);
    }), e;
  };

  function T(e) {
    return o.call(arguments, 1).forEach(function (t) {
      x(e, t, !0);
    }), e;
  }

  function x(t, e, n) {
    for (var o in e) n && (y(e[o]) || h(e[o])) ? (y(e[o]) && !y(t[o]) && (t[o] = {}), h(e[o]) && !h(t[o]) && (t[o] = []), x(t[o], e[o], n)) : void 0 !== e[o] && (t[o] = e[o]);
  }

  function j(t, e, n) {
    var o,
        u,
        a,
        r = (o = t, u = ["+", "#", ".", "/", ";", "?", "&"], {
      vars: a = [],
      expand: function (s) {
        return o.replace(/\{([^{}]+)\}|([^{}]+)/g, function (t, e, n) {
          if (e) {
            var o = null,
                r = [];

            if (-1 !== u.indexOf(e.charAt(0)) && (o = e.charAt(0), e = e.substr(1)), e.split(/,/g).forEach(function (t) {
              var e = /([^:*]*)(?::(\d+)|(\*))?/.exec(t);
              r.push.apply(r, function (t, e, n, o) {
                var r = t[n],
                    i = [];
                if (E(r) && "" !== r) {
                  if ("string" == typeof r || "number" == typeof r || "boolean" == typeof r) r = r.toString(), o && "*" !== o && (r = r.substring(0, parseInt(o, 10))), i.push(O(e, r, P(e) ? n : null));else if ("*" === o) Array.isArray(r) ? r.filter(E).forEach(function (t) {
                    i.push(O(e, t, P(e) ? n : null));
                  }) : Object.keys(r).forEach(function (t) {
                    E(r[t]) && i.push(O(e, r[t], t));
                  });else {
                    var s = [];
                    Array.isArray(r) ? r.filter(E).forEach(function (t) {
                      s.push(O(e, t));
                    }) : Object.keys(r).forEach(function (t) {
                      E(r[t]) && (s.push(encodeURIComponent(t)), s.push(O(e, r[t].toString())));
                    }), P(e) ? i.push(encodeURIComponent(n) + "=" + s.join(",")) : 0 !== s.length && i.push(s.join(","));
                  }
                } else ";" === e ? i.push(encodeURIComponent(n)) : "" !== r || "&" !== e && "?" !== e ? "" === r && i.push("") : i.push(encodeURIComponent(n) + "=");
                return i;
              }(s, o, e[1], e[2] || e[3])), a.push(e[1]);
            }), o && "+" !== o) {
              var i = ",";
              return "?" === o ? i = "&" : "#" !== o && (i = o), (0 !== r.length ? o : "") + r.join(i);
            }

            return r.join(",");
          }

          return C(n);
        });
      }
    }),
        i = r.expand(e);
    return n && n.push.apply(n, r.vars), i;
  }

  function E(t) {
    return null != t;
  }

  function P(t) {
    return ";" === t || "&" === t || "?" === t;
  }

  function O(t, e, n) {
    return e = "+" === t || "#" === t ? C(e) : encodeURIComponent(e), n ? encodeURIComponent(n) + "=" + e : e;
  }

  function C(t) {
    return t.split(/(%[0-9A-Fa-f]{2})/g).map(function (t) {
      return /%[0-9A-Fa-f]/.test(t) || (t = encodeURI(t)), t;
    }).join("");
  }

  function $(t, e) {
    var r,
        i = this || {},
        n = t;
    return d(t) && (n = {
      url: t,
      params: e
    }), n = T({}, $.options, i.$options, n), $.transforms.forEach(function (t) {
      var e, n, o;
      d(t) && (t = $.transform[t]), l(t) && (e = t, n = r, o = i.$vm, r = function (t) {
        return e.call(o, t, n);
      });
    }), r(n);
  }

  function U(i) {
    return new c(function (o) {
      var r = new XDomainRequest(),
          t = function (t) {
        var e = t.type,
            n = 0;
        "load" === e ? n = 200 : "error" === e && (n = 500), o(i.respondWith(r.responseText, {
          status: n
        }));
      };

      i.abort = function () {
        return r.abort();
      }, r.open(i.method, i.getUrl()), i.timeout && (r.timeout = i.timeout), r.onload = t, r.onabort = t, r.onerror = t, r.ontimeout = t, r.onprogress = function () {}, r.send(i.getBody());
    });
  }

  $.options = {
    url: "",
    root: null,
    params: {}
  }, $.transform = {
    template: function (e) {
      var t = [],
          n = j(e.url, e.params, t);
      return t.forEach(function (t) {
        delete e.params[t];
      }), n;
    },
    query: function (t, e) {
      var n = Object.keys($.options.params),
          o = {},
          r = e(t);
      return g(t.params, function (t, e) {
        -1 === n.indexOf(e) && (o[e] = t);
      }), (o = $.params(o)) && (r += (-1 == r.indexOf("?") ? "?" : "&") + o), r;
    },
    root: function (t, e) {
      var n,
          o,
          r = e(t);
      return d(t.root) && !/^(https?:)?\//.test(r) && (n = t.root, o = "/", r = (n && void 0 === o ? n.replace(/\s+$/, "") : n && o ? n.replace(new RegExp("[" + o + "]+$"), "") : n) + "/" + r), r;
    }
  }, $.transforms = ["template", "query", "root"], $.params = function (t) {
    var e = [],
        n = encodeURIComponent;
    return e.add = function (t, e) {
      l(e) && (e = e()), null === e && (e = ""), this.push(n(t) + "=" + n(e));
    }, function n(o, t, r) {
      var i,
          s = h(t),
          u = y(t);
      g(t, function (t, e) {
        i = m(t) || h(t), r && (e = r + "[" + (u || i ? e : "") + "]"), !r && s ? o.add(t.name, t.value) : i ? n(o, t, e) : o.add(e, t);
      });
    }(e, t), e.join("&").replace(/%20/g, "+");
  }, $.parse = function (t) {
    var e = document.createElement("a");
    return document.documentMode && (e.href = t, t = e.href), e.href = t, {
      href: e.href,
      protocol: e.protocol ? e.protocol.replace(/:$/, "") : "",
      port: e.port,
      host: e.host,
      hostname: e.hostname,
      pathname: "/" === e.pathname.charAt(0) ? e.pathname : "/" + e.pathname,
      search: e.search ? e.search.replace(/^\?/, "") : "",
      hash: e.hash ? e.hash.replace(/^#/, "") : ""
    };
  };
  var R = s && "withCredentials" in new XMLHttpRequest();

  function n(u) {
    return new c(function (o) {
      var t,
          r,
          e = u.jsonp || "callback",
          i = u.jsonpCallback || "_jsonp" + Math.random().toString(36).substr(2),
          s = null;
      t = function (t) {
        var e = t.type,
            n = 0;
        "load" === e && null !== s ? n = 200 : "error" === e && (n = 500), n && window[i] && (delete window[i], document.body.removeChild(r)), o(u.respondWith(s, {
          status: n
        }));
      }, window[i] = function (t) {
        s = JSON.stringify(t);
      }, u.abort = function () {
        t({
          type: "abort"
        });
      }, u.params[e] = i, u.timeout && setTimeout(u.abort, u.timeout), (r = document.createElement("script")).src = u.getUrl(), r.type = "text/javascript", r.async = !0, r.onload = t, r.onerror = t, document.body.appendChild(r);
    });
  }

  function A(r) {
    return new c(function (n) {
      var o = new XMLHttpRequest(),
          t = function (t) {
        var e = r.respondWith("response" in o ? o.response : o.responseText, {
          status: 1223 === o.status ? 204 : o.status,
          statusText: 1223 === o.status ? "No Content" : f(o.statusText)
        });
        g(f(o.getAllResponseHeaders()).split("\n"), function (t) {
          e.headers.append(t.slice(0, t.indexOf(":")), t.slice(t.indexOf(":") + 1));
        }), n(e);
      };

      r.abort = function () {
        return o.abort();
      }, o.open(r.method, r.getUrl(), !0), r.timeout && (o.timeout = r.timeout), r.responseType && "responseType" in o && (o.responseType = r.responseType), (r.withCredentials || r.credentials) && (o.withCredentials = !0), r.crossOrigin || r.headers.set("X-Requested-With", "XMLHttpRequest"), l(r.progress) && "GET" === r.method && o.addEventListener("progress", r.progress), l(r.downloadProgress) && o.addEventListener("progress", r.downloadProgress), l(r.progress) && /^(POST|PUT)$/i.test(r.method) && o.upload.addEventListener("progress", r.progress), l(r.uploadProgress) && o.upload && o.upload.addEventListener("progress", r.uploadProgress), r.headers.forEach(function (t, e) {
        o.setRequestHeader(e, t);
      }), o.onload = t, o.onabort = t, o.onerror = t, o.ontimeout = t, o.send(r.getBody());
    });
  }

  function S(s) {
    var u = __webpack_require__(20);

    return new c(function (e) {
      var n,
          t = s.getUrl(),
          o = s.getBody(),
          r = s.method,
          i = {};
      s.headers.forEach(function (t, e) {
        i[e] = t;
      }), u(t, {
        body: o,
        method: r,
        headers: i
      }).then(n = function (t) {
        var n = s.respondWith(t.body, {
          status: t.statusCode,
          statusText: f(t.statusMessage)
        });
        g(t.headers, function (t, e) {
          n.headers.set(e, t);
        }), e(n);
      }, function (t) {
        return n(t.response);
      });
    });
  }

  function k(t) {
    return (t.client || (s ? A : S))(t);
  }

  var I = function (t) {
    var n = this;
    this.map = {}, g(t, function (t, e) {
      return n.append(e, t);
    });
  };

  function L(t, n) {
    return Object.keys(t).reduce(function (t, e) {
      return p(n) === p(e) ? e : t;
    }, null);
  }

  I.prototype.has = function (t) {
    return null !== L(this.map, t);
  }, I.prototype.get = function (t) {
    var e = this.map[L(this.map, t)];
    return e ? e.join() : null;
  }, I.prototype.getAll = function (t) {
    return this.map[L(this.map, t)] || [];
  }, I.prototype.set = function (t, e) {
    this.map[function (t) {
      if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t)) throw new TypeError("Invalid character in header field name");
      return f(t);
    }(L(this.map, t) || t)] = [f(e)];
  }, I.prototype.append = function (t, e) {
    var n = this.map[L(this.map, t)];
    n ? n.push(f(e)) : this.set(t, e);
  }, I.prototype.delete = function (t) {
    delete this.map[L(this.map, t)];
  }, I.prototype.deleteAll = function () {
    this.map = {};
  }, I.prototype.forEach = function (n, o) {
    var r = this;
    g(this.map, function (t, e) {
      g(t, function (t) {
        return n.call(o, t, e, r);
      });
    });
  };

  var q = function (t, e) {
    var n,
        o,
        r,
        i = e.url,
        s = e.headers,
        u = e.status,
        a = e.statusText;
    this.url = i, this.ok = 200 <= u && u < 300, this.status = u || 0, this.statusText = a || "", this.headers = new I(s), d(this.body = t) ? this.bodyText = t : (r = t, "undefined" != typeof Blob && r instanceof Blob && (this.bodyBlob = t, (0 === (o = t).type.indexOf("text") || -1 !== o.type.indexOf("json")) && (this.bodyText = (n = t, new c(function (t) {
      var e = new FileReader();
      e.readAsText(n), e.onload = function () {
        t(e.result);
      };
    })))));
  };

  q.prototype.blob = function () {
    return v(this.bodyBlob);
  }, q.prototype.text = function () {
    return v(this.bodyText);
  }, q.prototype.json = function () {
    return v(this.text(), function (t) {
      return JSON.parse(t);
    });
  }, Object.defineProperty(q.prototype, "data", {
    get: function () {
      return this.body;
    },
    set: function (t) {
      this.body = t;
    }
  });

  var H = function (t) {
    var e;
    this.body = null, this.params = {}, w(this, t, {
      method: (e = t.method || "GET", e ? e.toUpperCase() : "")
    }), this.headers instanceof I || (this.headers = new I(this.headers));
  };

  H.prototype.getUrl = function () {
    return $(this);
  }, H.prototype.getBody = function () {
    return this.body;
  }, H.prototype.respondWith = function (t, e) {
    return new q(t, w(e || {}, {
      url: this.getUrl()
    }));
  };
  var B = {
    "Content-Type": "application/json;charset=utf-8"
  };

  function M(t) {
    var e = this || {},
        n = function (i) {
      var s = [k],
          u = [];

      function t(t) {
        for (; s.length;) {
          var e = s.pop();

          if (l(e)) {
            var o = void 0,
                n = void 0;
            if (m(o = e.call(i, t, function (t) {
              return n = t;
            }) || n)) return new c(function (t, n) {
              u.forEach(function (e) {
                o = v(o, function (t) {
                  return e.call(i, t) || t;
                }, n);
              }), v(o, t, n);
            }, i);
            l(o) && u.unshift(o);
          } else r = "Invalid interceptor of type " + typeof e + ", must be a function", "undefined" != typeof console && a && console.warn("[VueResource warn]: " + r);
        }

        var r;
      }

      return m(i) || (i = null), t.use = function (t) {
        s.push(t);
      }, t;
    }(e.$vm);

    return function (n) {
      o.call(arguments, 1).forEach(function (t) {
        for (var e in t) void 0 === n[e] && (n[e] = t[e]);
      });
    }(t || {}, e.$options, M.options), M.interceptors.forEach(function (t) {
      d(t) && (t = M.interceptor[t]), l(t) && n.use(t);
    }), n(new H(t)).then(function (t) {
      return t.ok ? t : c.reject(t);
    }, function (t) {
      var e;
      return t instanceof Error && (e = t, "undefined" != typeof console && console.error(e)), c.reject(t);
    });
  }

  function N(n, o, t, r) {
    var i = this || {},
        s = {};
    return g(t = w({}, N.actions, t), function (t, e) {
      t = T({
        url: n,
        params: w({}, o)
      }, r, t), s[e] = function () {
        return (i.$http || M)(function (t, e) {
          var n,
              o = w({}, t),
              r = {};

          switch (e.length) {
            case 2:
              r = e[0], n = e[1];
              break;

            case 1:
              /^(POST|PUT|PATCH)$/i.test(o.method) ? n = e[0] : r = e[0];
              break;

            case 0:
              break;

            default:
              throw "Expected up to 2 arguments [params, body], got " + e.length + " arguments";
          }

          return o.body = n, o.params = w({}, o.params, r), o;
        }(t, arguments));
      };
    }), s;
  }

  function D(n) {
    var t, e, o;
    D.installed || (e = (t = n).config, o = t.nextTick, r = o, a = e.debug || !e.silent, n.url = $, n.http = M, n.resource = N, n.Promise = c, Object.defineProperties(n.prototype, {
      $url: {
        get: function () {
          return b(n.url, this, this.$options.url);
        }
      },
      $http: {
        get: function () {
          return b(n.http, this, this.$options.http);
        }
      },
      $resource: {
        get: function () {
          return n.resource.bind(this);
        }
      },
      $promise: {
        get: function () {
          var e = this;
          return function (t) {
            return new n.Promise(t, e);
          };
        }
      }
    }));
  }

  return M.options = {}, M.headers = {
    put: B,
    post: B,
    patch: B,
    delete: B,
    common: {
      Accept: "application/json, text/plain, */*"
    },
    custom: {}
  }, M.interceptor = {
    before: function (t) {
      l(t.before) && t.before.call(this, t);
    },
    method: function (t) {
      t.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(t.method) && (t.headers.set("X-HTTP-Method-Override", t.method), t.method = "POST");
    },
    jsonp: function (t) {
      "JSONP" == t.method && (t.client = n);
    },
    json: function (t) {
      var e = t.headers.get("Content-Type") || "";
      return m(t.body) && 0 === e.indexOf("application/json") && (t.body = JSON.stringify(t.body)), function (o) {
        return o.bodyText ? v(o.text(), function (t) {
          var e, n;
          if (0 === (o.headers.get("Content-Type") || "").indexOf("application/json") || (n = (e = t).match(/^\s*(\[|\{)/)) && {
            "[": /]\s*$/,
            "{": /}\s*$/
          }[n[1]].test(e)) try {
            o.body = JSON.parse(t);
          } catch (t) {
            o.body = null;
          } else o.body = t;
          return o;
        }) : o;
      };
    },
    form: function (t) {
      var e;
      e = t.body, "undefined" != typeof FormData && e instanceof FormData ? t.headers.delete("Content-Type") : m(t.body) && t.emulateJSON && (t.body = $.params(t.body), t.headers.set("Content-Type", "application/x-www-form-urlencoded"));
    },
    header: function (n) {
      g(w({}, M.headers.common, n.crossOrigin ? {} : M.headers.custom, M.headers[p(n.method)]), function (t, e) {
        n.headers.has(e) || n.headers.set(e, t);
      });
    },
    cors: function (t) {
      if (s) {
        var e = $.parse(location.href),
            n = $.parse(t.getUrl());
        n.protocol === e.protocol && n.host === e.host || (t.crossOrigin = !0, t.emulateHTTP = !1, R || (t.client = U));
      }
    }
  }, M.interceptors = ["before", "method", "jsonp", "json", "form", "header", "cors"], ["get", "delete", "head", "jsonp"].forEach(function (n) {
    M[n] = function (t, e) {
      return this(w(e || {}, {
        url: t,
        method: n
      }));
    };
  }), ["post", "put", "patch"].forEach(function (o) {
    M[o] = function (t, e, n) {
      return this(w(n || {}, {
        url: t,
        method: o,
        body: e
      }));
    };
  }), N.actions = {
    get: {
      method: "GET"
    },
    save: {
      method: "POST"
    },
    query: {
      method: "GET"
    },
    update: {
      method: "PUT"
    },
    remove: {
      method: "DELETE"
    },
    delete: {
      method: "DELETE"
    }
  }, "undefined" != typeof window && window.Vue && window.Vue.use(D), D;
});

/***/ }),
/* 20 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(process) {/*!
  * vue-router v3.4.9
  * (c) 2020 Evan You
  * @license MIT
  */

/*  */
function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if (process.env.NODE_ENV !== 'production' && !condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

function extend(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }

  return a;
}
/*  */


var encodeReserveRE = /[!'()*]/g;

var encodeReserveReplacer = function (c) {
  return '%' + c.charCodeAt(0).toString(16);
};

var commaRE = /%2C/g; // fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas

var encode = function (str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

function decode(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    if (process.env.NODE_ENV !== 'production') {
      warn(false, "Error decoding \"" + str + "\". Leaving it intact.");
    }
  }

  return str;
}

function resolveQuery(query, extraQuery, _parseQuery) {
  if (extraQuery === void 0) extraQuery = {};
  var parse = _parseQuery || parseQuery;
  var parsedQuery;

  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    process.env.NODE_ENV !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }

  for (var key in extraQuery) {
    var value = extraQuery[key];
    parsedQuery[key] = Array.isArray(value) ? value.map(castQueryParamValue) : castQueryParamValue(value);
  }

  return parsedQuery;
}

var castQueryParamValue = function (value) {
  return value == null || typeof value === 'object' ? value : String(value);
};

function parseQuery(query) {
  var res = {};
  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });
  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }

        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}
/*  */


var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom, router) {
  var stringifyQuery = router && router.options.stringifyQuery;
  var query = location.query || {};

  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery),
    matched: record ? formatMatch(record) : []
  };

  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery);
  }

  return Object.freeze(route);
}

function clone(value) {
  if (Array.isArray(value)) {
    return value.map(clone);
  } else if (value && typeof value === 'object') {
    var res = {};

    for (var key in value) {
      res[key] = clone(value[key]);
    }

    return res;
  } else {
    return value;
  }
} // the starting route that represents the initial state


var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];

  while (record) {
    res.unshift(record);
    record = record.parent;
  }

  return res;
}

function getFullPath(ref, _stringifyQuery) {
  var path = ref.path;
  var query = ref.query;
  if (query === void 0) query = {};
  var hash = ref.hash;
  if (hash === void 0) hash = '';
  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {}; // handle null value #1566

  if (!a || !b) {
    return a === b;
  }

  var aKeys = Object.keys(a).sort();
  var bKeys = Object.keys(b).sort();

  if (aKeys.length !== bKeys.length) {
    return false;
  }

  return aKeys.every(function (key, i) {
    var aVal = a[key];
    var bKey = bKeys[i];

    if (bKey !== key) {
      return false;
    }

    var bVal = b[key]; // query values can be null and undefined

    if (aVal == null || bVal == null) {
      return aVal === bVal;
    } // check nested equality


    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal);
    }

    return String(aVal) === String(bVal);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }

  return true;
}

function handleRouteEntered(route) {
  for (var i = 0; i < route.matched.length; i++) {
    var record = route.matched[i];

    for (var name in record.instances) {
      var instance = record.instances[name];
      var cbs = record.enteredCbs[name];

      if (!instance || !cbs) {
        continue;
      }

      delete record.enteredCbs[name];

      for (var i$1 = 0; i$1 < cbs.length; i$1++) {
        if (!instance._isBeingDestroyed) {
          cbs[i$1](instance);
        }
      }
    }
  }
}

var View = {
  name: 'RouterView',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data; // used by devtools to display a router-view badge

    data.routerView = true; // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots

    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {}); // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.

    var depth = 0;
    var inactive = false;

    while (parent && parent._routerRoot !== parent) {
      var vnodeData = parent.$vnode ? parent.$vnode.data : {};

      if (vnodeData.routerView) {
        depth++;
      }

      if (vnodeData.keepAlive && parent._directInactive && parent._inactive) {
        inactive = true;
      }

      parent = parent.$parent;
    }

    data.routerViewDepth = depth; // render previous view if the tree is inactive and kept-alive

    if (inactive) {
      var cachedData = cache[name];
      var cachedComponent = cachedData && cachedData.component;

      if (cachedComponent) {
        // #2301
        // pass props
        if (cachedData.configProps) {
          fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps);
        }

        return h(cachedComponent, data, children);
      } else {
        // render previous empty view
        return h();
      }
    }

    var matched = route.matched[depth];
    var component = matched && matched.components[name]; // render empty node if no matched route or no config component

    if (!matched || !component) {
      cache[name] = null;
      return h();
    } // cache component


    cache[name] = {
      component: component
    }; // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks

    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];

      if (val && current !== vm || !val && current === vm) {
        matched.instances[name] = val;
      }
    } // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;

    (data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    }; // register instance in init hook
    // in case kept-alive component be actived when routes changed


    data.hook.init = function (vnode) {
      if (vnode.data.keepAlive && vnode.componentInstance && vnode.componentInstance !== matched.instances[name]) {
        matched.instances[name] = vnode.componentInstance;
      } // if the route transition has already been confirmed then we weren't
      // able to call the cbs during confirmation as the component was not
      // registered yet, so we call it here.


      handleRouteEntered(route);
    };

    var configProps = matched.props && matched.props[name]; // save route and configProps in cache

    if (configProps) {
      extend(cache[name], {
        route: route,
        configProps: configProps
      });
      fillPropsinData(component, data, route, configProps);
    }

    return h(component, data, children);
  }
};

function fillPropsinData(component, data, route, configProps) {
  // resolve props
  var propsToPass = data.props = resolveProps(route, configProps);

  if (propsToPass) {
    // clone to prevent mutation
    propsToPass = data.props = extend({}, propsToPass); // pass non-declared props as attrs

    var attrs = data.attrs = data.attrs || {};

    for (var key in propsToPass) {
      if (!component.props || !(key in component.props)) {
        attrs[key] = propsToPass[key];
        delete propsToPass[key];
      }
    }
  }
}

function resolveProps(route, config) {
  switch (typeof config) {
    case 'undefined':
      return;

    case 'object':
      return config;

    case 'function':
      return config(route);

    case 'boolean':
      return config ? route.params : undefined;

    default:
      if (process.env.NODE_ENV !== 'production') {
        warn(false, "props in \"" + route.path + "\" is a " + typeof config + ", " + "expecting an object, function or boolean.");
      }

  }
}
/*  */


function resolvePath(relative, base, append) {
  var firstChar = relative.charAt(0);

  if (firstChar === '/') {
    return relative;
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative;
  }

  var stack = base.split('/'); // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)

  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  } // resolve relative path


  var segments = relative.replace(/^\//, '').split('/');

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];

    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  } // ensure leading slash


  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';
  var hashIndex = path.indexOf('#');

  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');

  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};
/**
 * Expose `pathToRegexp`.
 */


var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;
/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */

var PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)', // Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');
/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */

function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length; // Ignore already escaped sequences.

    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7]; // Push the current path onto the tokens.

    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;
    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  } // Match any characters still remaining.


  if (index < str.length) {
    path += str.substr(index);
  } // If the path exists, push it onto the end.


  if (path) {
    tokens.push(path);
  }

  return tokens;
}
/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */


function compile(str, options) {
  return tokensToFunction(parse(str, options), options);
}
/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */


function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */


function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
/**
 * Expose a method for transforming tokens into the path function.
 */


function tokensToFunction(tokens, options) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length); // Compile all the patterns before compilation.

  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;
        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}
/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */


function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}
/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */


function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}
/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */


function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}
/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */


function flags(options) {
  return options && options.sensitive ? '' : 'i';
}
/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */


function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}
/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */


function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}
/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */


function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */


function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options =
    /** @type {!Object} */
    keys || options;
    keys = [];
  }

  options = options || {};
  var strict = options.strict;
  var end = options.end !== false;
  var route = ''; // Iterate over the tokens and create our regexp string.

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';
      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter; // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".

  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */


function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options =
    /** @type {!Object} */
    keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path,
    /** @type {!Array} */
    keys);
  }

  if (isarray(path)) {
    return arrayToRegexp(
    /** @type {!Array} */
    path,
    /** @type {!Array} */
    keys, options);
  }

  return stringToRegexp(
  /** @type {string} */
  path,
  /** @type {!Array} */
  keys, options);
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;
/*  */
// $flow-disable-line

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  params = params || {};

  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = pathToRegexp_1.compile(path)); // Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}
    // and fix #3106 so that you can work with location descriptor object having params.pathMatch equal to empty string

    if (typeof params.pathMatch === 'string') {
      params[0] = params.pathMatch;
    }

    return filler(params, {
      pretty: true
    });
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      // Fix #3072 no warn if `pathMatch` is string
      warn(typeof params.pathMatch === 'string', "missing param for " + routeMsg + ": " + e.message);
    }

    return '';
  } finally {
    // delete the 0 if it was added
    delete params[0];
  }
}
/*  */


function normalizeLocation(raw, current, append, router) {
  var next = typeof raw === 'string' ? {
    path: raw
  } : raw; // named target

  if (next._normalized) {
    return next;
  } else if (next.name) {
    next = extend({}, raw);
    var params = next.params;

    if (params && typeof params === 'object') {
      next.params = extend({}, params);
    }

    return next;
  } // relative params


  if (!next.path && next.params && current) {
    next = extend({}, next);
    next._normalized = true;
    var params$1 = extend(extend({}, current.params), next.params);

    if (current.name) {
      next.name = current.name;
      next.params = params$1;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params$1, "path " + current.path);
    } else if (process.env.NODE_ENV !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }

    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;
  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);
  var hash = next.hash || parsedPath.hash;

  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}
/*  */
// work around weird flow bug


var toTypes = [String, Object];
var eventTypes = [String, Array];

var noop = function () {};

var Link = {
  name: 'RouterLink',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    ariaCurrentValue: {
      type: String,
      default: 'page'
    },
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;
    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;
    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass; // Support global empty active class

    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;
    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;
    var compareTarget = route.redirectedFrom ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router) : route;
    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);
    var ariaCurrentValue = classes[exactActiveClass] ? this.ariaCurrentValue : null;

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location, noop);
        } else {
          router.push(location, noop);
        }
      }
    };

    var on = {
      click: guardEvent
    };

    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };
    var scopedSlot = !this.$scopedSlots.$hasNormal && this.$scopedSlots.default && this.$scopedSlots.default({
      href: href,
      route: route,
      navigate: handler,
      isActive: classes[activeClass],
      isExactActive: classes[exactActiveClass]
    });

    if (scopedSlot) {
      if (scopedSlot.length === 1) {
        return scopedSlot[0];
      } else if (scopedSlot.length > 1 || !scopedSlot.length) {
        if (process.env.NODE_ENV !== 'production') {
          warn(false, "RouterLink with to=\"" + this.to + "\" is trying to use a scoped slot but it didn't provide exactly one child. Wrapping the content with a span element.");
        }

        return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot);
      }
    }

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = {
        href: href,
        'aria-current': ariaCurrentValue
      };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);

      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var aData = a.data = extend({}, a.data);
        aData.on = aData.on || {}; // transform existing events in both objects into arrays so we can push later

        for (var event in aData.on) {
          var handler$1 = aData.on[event];

          if (event in on) {
            aData.on[event] = Array.isArray(handler$1) ? handler$1 : [handler$1];
          }
        } // append new listeners for router-link


        for (var event$1 in on) {
          if (event$1 in aData.on) {
            // on[event] is always a function
            aData.on[event$1].push(on[event$1]);
          } else {
            aData.on[event$1] = handler;
          }
        }

        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
        aAttrs['aria-current'] = ariaCurrentValue;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {
    return;
  } // don't redirect when preventDefault called


  if (e.defaultPrevented) {
    return;
  } // don't redirect on right click


  if (e.button !== undefined && e.button !== 0) {
    return;
  } // don't redirect if `target="_blank"`


  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');

    if (/\b_blank\b/i.test(target)) {
      return;
    }
  } // this may be a Weex event which doesn't have this method


  if (e.preventDefault) {
    e.preventDefault();
  }

  return true;
}

function findAnchor(children) {
  if (children) {
    var child;

    for (var i = 0; i < children.length; i++) {
      child = children[i];

      if (child.tag === 'a') {
        return child;
      }

      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed && _Vue === Vue) {
    return;
  }

  install.installed = true;
  _Vue = Vue;

  var isDef = function (v) {
    return v !== undefined;
  };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;

    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;

        this._router.init(this);

        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = this.$parent && this.$parent._routerRoot || this;
      }

      registerInstance(this, this);
    },
    destroyed: function destroyed() {
      registerInstance(this);
    }
  });
  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this._routerRoot._router;
    }
  });
  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this._routerRoot._route;
    }
  });
  Vue.component('RouterView', View);
  Vue.component('RouterLink', Link);
  var strats = Vue.config.optionMergeStrategies; // use the same hook merging strategy for route hooks

  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}
/*  */


var inBrowser = typeof window !== 'undefined';
/*  */

function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || []; // $flow-disable-line

  var pathMap = oldPathMap || Object.create(null); // $flow-disable-line

  var nameMap = oldNameMap || Object.create(null);
  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  }); // ensure wildcard routes are always at the end

  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  if (process.env.NODE_ENV === 'development') {
    // warn if routes do not include leading slashes
    var found = pathList // check for missing leading slash
    .filter(function (path) {
      return path && path.charAt(0) !== '*' && path.charAt(0) !== '/';
    });

    if (found.length > 0) {
      var pathNames = found.map(function (path) {
        return "- " + path;
      }).join('\n');
      warn(false, "Non-nested routes must include a leading slash character. Fix the following routes: \n" + pathNames);
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;

  if (process.env.NODE_ENV !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
    warn( // eslint-disable-next-line no-control-regex
    !/[^\u0000-\u007F]+/.test(path), "Route with path \"" + path + "\" contains unencoded characters, make sure " + "your path is correctly encoded before passing it to the router. Use " + "encodeURI to encode static segments of your path.");
  }

  var pathToRegexpOptions = route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || {
      default: route.component
    },
    instances: {},
    enteredCbs: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : {
      default: route.props
    }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && !route.redirect && route.children.some(function (child) {
        return /^\/?$/.test(child.path);
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }

    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];

    for (var i = 0; i < aliases.length; ++i) {
      var alias = aliases[i];

      if (process.env.NODE_ENV !== 'production' && alias === path) {
        warn(false, "Found an alias with the same value as the path: \"" + path + "\". You have to remove that alias. It will be ignored in development."); // skip in dev to make it work

        continue;
      }

      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs
      );
    }
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function compileRouteRegex(path, pathToRegexpOptions) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);

  if (process.env.NODE_ENV !== 'production') {
    var keys = Object.create(null);
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], "Duplicate param keys in route with path: \"" + path + "\"");
      keys[key.name] = true;
    });
  }

  return regex;
}

function normalizePath(path, parent, strict) {
  if (!strict) {
    path = path.replace(/\/$/, '');
  }

  if (path[0] === '/') {
    return path;
  }

  if (parent == null) {
    return path;
  }

  return cleanPath(parent.path + "/" + path);
}
/*  */


function createMatcher(routes, router) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];

      if (process.env.NODE_ENV !== 'production') {
        warn(record, "Route with name '" + name + "' does not exist");
      }

      if (!record) {
        return _createRoute(null, location);
      }

      var paramNames = record.regex.keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
      return _createRoute(record, location, redirectedFrom);
    } else if (location.path) {
      location.params = {};

      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];

        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom);
        }
      }
    } // no match


    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = {
        path: redirect
      };
    }

    if (!redirect || typeof redirect !== 'object') {
      if (process.env.NODE_ENV !== 'production') {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }

      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];

      if (process.env.NODE_ENV !== 'production') {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }

      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record); // 2. resolve params

      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\""); // 3. rematch with existing query and hash

      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      if (process.env.NODE_ENV !== 'production') {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }

      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });

    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }

    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }

    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }

    return createRoute(record, location, redirectedFrom, router);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(regex, path, params) {
  var m = path.match(regex);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];

    if (key) {
      // Fix #1994: using * with props: true generates a param named 0
      params[key.name || 'pathMatch'] = typeof m[i] === 'string' ? decode(m[i]) : m[i];
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}
/*  */
// use User Timing api (if present) for more accurate key precision


var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

function genStateKey() {
  return Time.now().toFixed(3);
}

var _key = genStateKey();

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  return _key = key;
}
/*  */


var positionStore = Object.create(null);

function setupScroll() {
  // Prevent browser scroll behavior on History popstate
  if ('scrollRestoration' in window.history) {
    window.history.scrollRestoration = 'manual';
  } // Fix for #1585 for Firefox
  // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678
  // Fix for #2774 Support for apps loaded from Windows file shares not mapped to network drives: replaced location.origin with
  // window.location.protocol + '//' + window.location.host
  // location.host contains the port and location.hostname doesn't


  var protocolAndPath = window.location.protocol + '//' + window.location.host;
  var absolutePath = window.location.href.replace(protocolAndPath, ''); // preserve existing history state as it could be overriden by the user

  var stateCopy = extend({}, window.history.state);
  stateCopy.key = getStateKey();
  window.history.replaceState(stateCopy, '', absolutePath);
  window.addEventListener('popstate', handlePopState);
  return function () {
    window.removeEventListener('popstate', handlePopState);
  };
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;

  if (!behavior) {
    return;
  }

  if (process.env.NODE_ENV !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  } // wait until re-render finishes before scrolling


  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior.call(router, to, from, isPop ? position : null);

    if (!shouldScroll) {
      return;
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll.then(function (shouldScroll) {
        scrollToPosition(shouldScroll, position);
      }).catch(function (err) {
        if (process.env.NODE_ENV !== 'production') {
          assert(false, err.toString());
        }
      });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();

  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function handlePopState(e) {
  saveScrollPosition();

  if (e.state && e.state.key) {
    setStateKey(e.state.key);
  }
}

function getScrollPosition() {
  var key = getStateKey();

  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function normalizeOffset(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

var hashStartsWithNumberRE = /^#\d/;

function scrollToPosition(shouldScroll, position) {
  var isObject = typeof shouldScroll === 'object';

  if (isObject && typeof shouldScroll.selector === 'string') {
    // getElementById would still fail if the selector contains a more complicated query like #main[data-attr]
    // but at the same time, it doesn't make much sense to select an element with an id and an extra selector
    var el = hashStartsWithNumberRE.test(shouldScroll.selector) // $flow-disable-line
    ? document.getElementById(shouldScroll.selector.slice(1)) // $flow-disable-line
    : document.querySelector(shouldScroll.selector);

    if (el) {
      var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    // $flow-disable-line
    if ('scrollBehavior' in document.documentElement.style) {
      window.scrollTo({
        left: position.x,
        top: position.y,
        // $flow-disable-line
        behavior: shouldScroll.behavior
      });
    } else {
      window.scrollTo(position.x, position.y);
    }
  }
}
/*  */


var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && typeof window.history.pushState === 'function';
}();

function pushState(url, replace) {
  saveScrollPosition(); // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls

  var history = window.history;

  try {
    if (replace) {
      // preserve existing history state as it could be overriden by the user
      var stateCopy = extend({}, history.state);
      stateCopy.key = getStateKey();
      history.replaceState(stateCopy, '', url);
    } else {
      history.pushState({
        key: setStateKey(genStateKey())
      }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}
/*  */


function runQueue(queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };

  step(0);
} // When changing thing, also edit router.d.ts


var NavigationFailureType = {
  redirected: 2,
  aborted: 4,
  cancelled: 8,
  duplicated: 16
};

function createNavigationRedirectedError(from, to) {
  return createRouterError(from, to, NavigationFailureType.redirected, "Redirected when going from \"" + from.fullPath + "\" to \"" + stringifyRoute(to) + "\" via a navigation guard.");
}

function createNavigationDuplicatedError(from, to) {
  var error = createRouterError(from, to, NavigationFailureType.duplicated, "Avoided redundant navigation to current location: \"" + from.fullPath + "\"."); // backwards compatible with the first introduction of Errors

  error.name = 'NavigationDuplicated';
  return error;
}

function createNavigationCancelledError(from, to) {
  return createRouterError(from, to, NavigationFailureType.cancelled, "Navigation cancelled from \"" + from.fullPath + "\" to \"" + to.fullPath + "\" with a new navigation.");
}

function createNavigationAbortedError(from, to) {
  return createRouterError(from, to, NavigationFailureType.aborted, "Navigation aborted from \"" + from.fullPath + "\" to \"" + to.fullPath + "\" via a navigation guard.");
}

function createRouterError(from, to, type, message) {
  var error = new Error(message);
  error._isRouter = true;
  error.from = from;
  error.to = to;
  error.type = type;
  return error;
}

var propertiesToLog = ['params', 'query', 'hash'];

function stringifyRoute(to) {
  if (typeof to === 'string') {
    return to;
  }

  if ('path' in to) {
    return to.path;
  }

  var location = {};
  propertiesToLog.forEach(function (key) {
    if (key in to) {
      location[key] = to[key];
    }
  });
  return JSON.stringify(location, null, 2);
}

function isError(err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1;
}

function isNavigationFailure(err, errorType) {
  return isError(err) && err._isRouter && (errorType == null || err.type === errorType);
}
/*  */


function resolveAsyncComponents(matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;
    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;
        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          } // save resolved on async factory in case it's used elsewhere


          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;

          if (pending <= 0) {
            next();
          }
        });
        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          process.env.NODE_ENV !== 'production' && warn(false, msg);

          if (!error) {
            error = isError(reason) ? reason : new Error(msg);
            next(error);
          }
        });
        var res;

        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }

        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;

            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) {
      next();
    }
  };
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

var hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

function isESModule(obj) {
  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';
} // in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.


function once(fn) {
  var called = false;
  return function () {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    if (called) {
      return;
    }

    called = true;
    return fn.apply(this, args);
  };
}
/*  */


var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base); // start with a route object that stands for "nowhere"

  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
  this.listeners = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);

    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError(errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;
  var route; // catch redirect option https://github.com/vuejs/vue-router/issues/3201

  try {
    route = this.router.match(location, this.current);
  } catch (e) {
    this.errorCbs.forEach(function (cb) {
      cb(e);
    }); // Exception should still be thrown

    throw e;
  }

  var prev = this.current;
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();
    this$1.router.afterHooks.forEach(function (hook) {
      hook && hook(route, prev);
    }); // fire ready cbs once

    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }

    if (err && !this$1.ready) {
      // Initial redirection should not mark the history as ready yet
      // because it's triggered by the redirection instead
      // https://github.com/vuejs/vue-router/issues/3225
      // https://github.com/vuejs/vue-router/issues/3331
      if (!isNavigationFailure(err, NavigationFailureType.redirected) || prev !== START) {
        this$1.ready = true;
        this$1.readyErrorCbs.forEach(function (cb) {
          cb(err);
        });
      }
    }
  });
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;
  var current = this.current;
  this.pending = route;

  var abort = function (err) {
    // changed after adding errors with
    // https://github.com/vuejs/vue-router/pull/3047 before that change,
    // redirect and aborted navigation would produce an err == null
    if (!isNavigationFailure(err) && isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }

    onAbort && onAbort(err);
  };

  var lastRouteIndex = route.matched.length - 1;
  var lastCurrentIndex = current.matched.length - 1;

  if (isSameRoute(route, current) && // in the case the route map has been dynamically appended to
  lastRouteIndex === lastCurrentIndex && route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]) {
    this.ensureURL();
    return abort(createNavigationDuplicatedError(current, route));
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;
  var queue = [].concat( // in-component leave guards
  extractLeaveGuards(deactivated), // global before hooks
  this.router.beforeHooks, // in-component update hooks
  extractUpdateHooks(updated), // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }), // async components
  resolveAsyncComponents(activated));

  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort(createNavigationCancelledError(current, route));
    }

    try {
      hook(route, current, function (to) {
        if (to === false) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(createNavigationAbortedError(current, route));
        } else if (isError(to)) {
          this$1.ensureURL(true);
          abort(to);
        } else if (typeof to === 'string' || typeof to === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {
          // next('/') or next({ path: '/' }) -> redirect
          abort(createNavigationRedirectedError(current, route));

          if (typeof to === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort(createNavigationCancelledError(current, route));
      }

      this$1.pending = null;
      onComplete(route);

      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          handleRouteEntered(route);
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  this.current = route;
  this.cb && this.cb(route);
};

History.prototype.setupListeners = function setupListeners() {// Default implementation is empty
};

History.prototype.teardown = function teardown() {
  // clean up event listeners
  // https://github.com/vuejs/vue-router/issues/2341
  this.listeners.forEach(function (cleanupListener) {
    cleanupListener();
  });
  this.listeners = []; // reset current history route
  // https://github.com/vuejs/vue-router/issues/3294

  this.current = START;
  this.pending = null;
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/'; // strip full URL origin

      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  } // make sure there's the starting slash


  if (base.charAt(0) !== '/') {
    base = '/' + base;
  } // remove trailing slash


  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);

  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }

  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);

    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }

  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  if (instance) {
    return function boundRouteGuard() {
      return guard.apply(instance, arguments);
    };
  }
}

function extractEnterGuards(activated) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key);
  });
}

function bindEnterGuard(guard, match, key) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      if (typeof cb === 'function') {
        if (!match.enteredCbs[key]) {
          match.enteredCbs[key] = [];
        }

        match.enteredCbs[key].push(cb);
      }

      next(cb);
    });
  };
}
/*  */


var HTML5History = /*@__PURE__*/function (History) {
  function HTML5History(router, base) {
    History.call(this, router, base);
    this._startLocation = getLocation(this.base);
  }

  if (History) HTML5History.__proto__ = History;
  HTML5History.prototype = Object.create(History && History.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    if (this.listeners.length > 0) {
      return;
    }

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      this.listeners.push(setupScroll());
    }

    var handleRoutingEvent = function () {
      var current = this$1.current; // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.

      var location = getLocation(this$1.base);

      if (this$1.current === START && location === this$1._startLocation) {
        return;
      }

      this$1.transitionTo(location, function (route) {
        if (supportsScroll) {
          handleScroll(router, route, current, true);
        }
      });
    };

    window.addEventListener('popstate', handleRoutingEvent);
    this.listeners.push(function () {
      window.removeEventListener('popstate', handleRoutingEvent);
    });
  };

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;

  if (base && path.toLowerCase().indexOf(base.toLowerCase()) === 0) {
    path = path.slice(base.length);
  }

  return (path || '/') + window.location.search + window.location.hash;
}
/*  */


var HashHistory = /*@__PURE__*/function (History) {
  function HashHistory(router, base, fallback) {
    History.call(this, router, base); // check history fallback deeplinking

    if (fallback && checkFallback(this.base)) {
      return;
    }

    ensureSlash();
  }

  if (History) HashHistory.__proto__ = History;
  HashHistory.prototype = Object.create(History && History.prototype);
  HashHistory.prototype.constructor = HashHistory; // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early

  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    if (this.listeners.length > 0) {
      return;
    }

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      this.listeners.push(setupScroll());
    }

    var handleRoutingEvent = function () {
      var current = this$1.current;

      if (!ensureSlash()) {
        return;
      }

      this$1.transitionTo(getHash(), function (route) {
        if (supportsScroll) {
          handleScroll(this$1.router, route, current, true);
        }

        if (!supportsPushState) {
          replaceHash(route.fullPath);
        }
      });
    };

    var eventType = supportsPushState ? 'popstate' : 'hashchange';
    window.addEventListener(eventType, handleRoutingEvent);
    this.listeners.push(function () {
      window.removeEventListener(eventType, handleRoutingEvent);
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;

    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);

  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();

  if (path.charAt(0) === '/') {
    return true;
  }

  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#'); // empty path

  if (index < 0) {
    return '';
  }

  href = href.slice(index + 1);
  return href;
}

function getUrl(path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return base + "#" + path;
}

function pushHash(path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash(path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}
/*  */


var AbstractHistory = /*@__PURE__*/function (History) {
  function AbstractHistory(router, base) {
    History.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History) AbstractHistory.__proto__ = History;
  AbstractHistory.prototype = Object.create(History && History.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;
    var targetIndex = this.index + n;

    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }

    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      var prev = this$1.current;
      this$1.index = targetIndex;
      this$1.updateRoute(route);
      this$1.router.afterHooks.forEach(function (hook) {
        hook && hook(route, prev);
      });
    }, function (err) {
      if (isNavigationFailure(err, NavigationFailureType.duplicated)) {
        this$1.index = targetIndex;
      }
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {// noop
  };

  return AbstractHistory;
}(History);
/*  */


var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};
  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);
  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;

  if (this.fallback) {
    mode = 'hash';
  }

  if (!inBrowser) {
    mode = 'abstract';
  }

  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;

    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;

    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;

    default:
      if (process.env.NODE_ENV !== 'production') {
        assert(false, "invalid mode: " + mode);
      }

  }
};

var prototypeAccessors = {
  currentRoute: {
    configurable: true
  }
};

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app
/* Vue component instance */
) {
  var this$1 = this;
  process.env.NODE_ENV !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");
  this.apps.push(app); // set up app destroyed handler
  // https://github.com/vuejs/vue-router/issues/2639

  app.$once('hook:destroyed', function () {
    // clean out app from this.apps array once destroyed
    var index = this$1.apps.indexOf(app);

    if (index > -1) {
      this$1.apps.splice(index, 1);
    } // ensure we still have a main app or null if no apps
    // we do not release the router so it can be reused


    if (this$1.app === app) {
      this$1.app = this$1.apps[0] || null;
    }

    if (!this$1.app) {
      this$1.history.teardown();
    }
  }); // main app previously initialized
  // return as we don't need to set up new history listener

  if (this.app) {
    return;
  }

  this.app = app;
  var history = this.history;

  if (history instanceof HTML5History || history instanceof HashHistory) {
    var handleInitialScroll = function (routeOrError) {
      var from = history.current;
      var expectScroll = this$1.options.scrollBehavior;
      var supportsScroll = supportsPushState && expectScroll;

      if (supportsScroll && 'fullPath' in routeOrError) {
        handleScroll(this$1, routeOrError, from, false);
      }
    };

    var setupListeners = function (routeOrError) {
      history.setupListeners();
      handleInitialScroll(routeOrError);
    };

    history.transitionTo(history.getCurrentLocation(), setupListeners, setupListeners);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function beforeResolve(fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  return registerHook(this.afterHooks, fn);
};

VueRouter.prototype.onReady = function onReady(cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError(errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  var this$1 = this; // $flow-disable-line

  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
    return new Promise(function (resolve, reject) {
      this$1.history.push(location, resolve, reject);
    });
  } else {
    this.history.push(location, onComplete, onAbort);
  }
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  var this$1 = this; // $flow-disable-line

  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
    return new Promise(function (resolve, reject) {
      this$1.history.replace(location, resolve, reject);
    });
  } else {
    this.history.replace(location, onComplete, onAbort);
  }
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;

  if (!route) {
    return [];
  }

  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  current = current || this.history.current;
  var location = normalizeLocation(to, current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);

  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);

    if (i > -1) {
      list.splice(i, 1);
    }
  };
}

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '3.4.9';
VueRouter.isNavigationFailure = isNavigationFailure;
VueRouter.NavigationFailureType = NavigationFailureType;

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

/* harmony default export */ __webpack_exports__["default"] = (VueRouter);
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(4)))

/***/ }),
/* 22 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = {
  data: function () {
    return {
      token: '',
      name: '',
      email: ''
    };
  },
  methods: {
    updateData: function (data) {
      this.name = data.nome;
      this.token = data.token;
      this.email = data.email;
    }
  }
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var axios = __webpack_require__(7);

module.exports = {
  methods: {
    resquestLogin: function (data, callback) {
      var self = this;
      self.$http.post('http://desafio.conexasaude.com.br/api/login', data).then(function (response) {
        if (response.status == 200) {
          self.updateData(response.body.data);
          self.$router.push({
            path: "home"
          });
        } else {
          callback();
        }
      });
    },
    resquestEnroll: function (data, callbackSuccess, callbackFail) {
      var token = this.token;
      axios.request({
        baseURL: 'http://desafio.conexasaude.com.br/api/consulta',
        method: 'post',
        data: data,
        headers: {
          'Authorization': `Bearer ${token}`,
          'content-type': 'application/json;charset=UTF-8'
        }
      }).then(response => {
        if (response.status == 200 || response.status == 201) {
          callbackSuccess(response.data);
        } else {
          callbackFail();
        }
      });
    }
  }
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

var bind = __webpack_require__(8);

var Axios = __webpack_require__(26);

var mergeConfig = __webpack_require__(14);

var defaults = __webpack_require__(11);
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = __webpack_require__(15);
axios.CancelToken = __webpack_require__(39);
axios.isCancel = __webpack_require__(10); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = __webpack_require__(40);
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports.default = axios;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

var buildURL = __webpack_require__(9);

var InterceptorManager = __webpack_require__(27);

var dispatchRequest = __webpack_require__(28);

var mergeConfig = __webpack_require__(14);
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */


function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config); // Set config.method

  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  } // Hook up interceptors middleware


  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

var transformData = __webpack_require__(29);

var isCancel = __webpack_require__(10);

var defaults = __webpack_require__(11);
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Ensure headers exist

  config.headers = config.headers || {}; // Transform request data

  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData(response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });
  return data;
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(13);
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };

  return error;
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isAbsoluteURL = __webpack_require__(35);

var combineURLs = __webpack_require__(36);
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */


module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }

  return requestedURL;
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(15);
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var axios = __webpack_require__(7);

module.exports = {
  methods: {
    resquestList: function (callbackSuccess, callbackFail) {
      var token = this.token;
      axios.request({
        baseURL: 'http://desafio.conexasaude.com.br/api/consultas',
        method: 'get',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }).then(response => {
        if (response.status == 200) {
          callbackSuccess(response.data);
        } else {
          callbackFail();
        }
      });
    },
    requestDetails: function (id, callbackSuccess, callbackFail) {
      var token = this.token;
      axios.request({
        baseURL: 'http://desafio.conexasaude.com.br/api/consulta/' + id,
        method: 'get',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }).then(response => {
        if (response.status == 200) {
          console.log(response.data);
          callbackSuccess(response.data);
        } else {
          console.error('Houve um erro na chamada dos detalhes'); // callbackFail();
        }
      });
    }
  }
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = [{
  path: '/home',
  name: 'home',
  component: __webpack_require__(43),
  props: {
    name: true
  }
}, {
  path: '/listMedicalAppointment',
  name: 'listMedicalAppointment',
  component: __webpack_require__(44)
}, {
  path: '/details/',
  name: 'details',
  component: __webpack_require__(45),
  props: true
}, {
  path: '/enrollMedicalAppointment',
  component: __webpack_require__(46)
}, {
  path: '/',
  name: 'login',
  component: __webpack_require__(5)
}];

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Vue) {module.exports = Vue.component('home', {
  component: __webpack_require__(2),
  props: {
    name: String
  },
  mounted: function () {
    this.name = this.$root.name;
  },
  template: `
        <div class="row">
            <customMenu></customMenu>
            <div class="col-md-12 content">
                <h2>Bem vindo: {{name}} </h2>
            </div>
        </div>
    `
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Vue) {module.exports = Vue.component('list-medical-appointment', {
  component: __webpack_require__(2),
  template: `
    <div class="row">
        <customMenu></customMenu>
        <div class="col-md-12 content">
            <h2>Lista de consultas</h2>
            <div>
                <table class="table table-striped">
                    <thead class="thead-dark">
                    <tr>
                        <th scope="col">Paciente</th>
                        <th scope="col">Data da Consulta</th>
                        <th scope="col">Observação</th>
                        <th scope="col"> </th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-for="(item, index) in list">
                        <td>{{item.paciente}}</td>
                        <td>{{item.dataConsulta}}</td>
                        <td>{{item.observacao}}</td>
                        <td><a href="#" v-on:click.prevent="showDetails(item.id)">Detalhes</a></td>
                    </tr>
                    </tbody>
                </table>
            </div>        
        </div>
    </div>`,
  data: function () {
    return {
      list: []
    };
  },
  mounted: function () {
    this.callRequestList();
  },
  methods: {
    callRequestList: function () {
      this.$root.resquestList(this.requestListSuccess, this.requestListFail);
    },
    requestListSuccess: function (list) {
      this.list = list.data;
    },
    requestListFail: function () {
      console.error('Não foi possível carregar a lista.');
    },
    showDetails: function (id) {
      // this.$root.requestDetails(id);
      this.$router.push({
        name: "details",
        params: {
          id: id
        }
      });
    }
  }
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Vue) {module.exports = Vue.component('details', {
  component: __webpack_require__(2),
  props: {
    id: {
      type: String,
      default: '10'
    }
  },
  mounted: function () {
    // this.name = this.$root.name;
    this.getData(this.id);
  },
  template: `
    <div class="row">
        <customMenu></customMenu>
        <div class="col-md-12 content">
            <h2>Detalhes</h2>
            <div class="row">
                <div class="col-md-4">
                    <p><span>Paciente:</span><br>{{name}}</p>
                </div>
                <div class="col-md-4">
                    <p><span>Data da consulta:</span><br>{{dateAppointment}}</p>
                </div>
                <div class="col-md-4">
                    <p><span>Médico:</span><br>{{medic}}</p>
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <p><span>Observações:</span><br>{{observes}}</p>
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <router-link to='/listMedicalAppointment'>
                        <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24">
                            <path d="M0 0h24v24H0z" fill="none"/>
                            <path d="M21 11H6.83l3.58-3.59L9 6l-6 6 6 6 1.41-1.41L6.83 13H21z"/>
                        </svg>
                        Voltar
                    </router-link>
                </div>
            </div>
        </div>
    </div>`,
  data: function () {
    return {
      name: '',
      observes: '',
      medic: '',
      dateAppointment: ''
    };
  },
  methods: {
    getData: function (id) {
      this.$root.requestDetails(id, this.successGetData, this.failGetData);
    },
    successGetData: function (response) {
      this.setData(response.data);
    },
    failGetData: function () {
      console.error('falha ao tentar carregar detalhes da consulta');
    },
    setData: function (data) {
      this.name = data.paciente;
      this.observes = data.observacao;
      this.medic = data.medico.nome;
      this.dateAppointment = data.dataConsulta;
    }
  }
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Vue) {module.exports = Vue.component('enroll', {
  component: __webpack_require__(2),
  mixins: [__webpack_require__(6)],
  template: `
    <div class="row">
        <customMenu></customMenu>
        <div class="col-md-12 content">
            <h2>Cadastrar consulta</h2>
            <div class="form-group">
                <form>
                    <fieldset>
                        <legend>Dados</legend>
                        <div  class="form-group">
                            <div class="alert alert-success" role="alert" v-if="success">
                                Cadastro realizado com sucesso
                            </div>
                            <div class="alert alert-danger" role="alert"  v-if="error">
                                Ocorreu um erro durante a gravação de dados
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="input-paciente">Paciente<span class="required"></span>:</label>
                            <input :class="{'errorField': submit && !validation.paciente}" type="text" id="input-paciente" name="input-paciente" class="form-control" placeholder="Nome do paciente" v-model="form.paciente"/>
                            <span class="error" v-if="submit && !validation.paciente">Preenhcer com o nome do paciente.</span>
                        </div>
                        <div class="form-group">
                            <label for="input-datetime">Data da consulta<span class="required"></span>:</label>
                            <input  :class="{'errorField': submit && !validation.dataConsulta}" type="datetime-local" id="input-datetime" name="input-password" class="form-control"  v-model="form.dataConsulta"/>
                            <span class="error" v-if="submit && !validation.dataConsulta">Preenhcer com a data e hora da consulta.</span>
                        </div>
                        <div class="form-group">
                            <label for="input-observe">Observação<span class="required"></span>:</label>
                            <textarea :class="{'errorField': submit && !validation.observacao}" id="input-observe"  class="form-control" rows="3" placeholder="Preencher com alguma observação..." name="input-observe" v-model="form.observacao"></textarea>
                            <span class="error" v-if="submit && !validation.observacao">Preenhcer com alguma observação.</span>
                        </div>
                        <div class="form-group">
                            <p>Itens com * são obrigatórios</p>
                            <button class="btn btn-danger" v-on:click.prevent="resetFields">Cancelar</button>
                            <input type="submit" class="btn btn-primary"  value="Gravar" v-on:click.prevent="enroll"/> 
                        </div>
                    </fieldset>
                </form>
            </div>
        </div>
    </div>
    `,
  data: function () {
    return {
      form: {
        paciente: '',
        dataConsulta: '',
        observacao: '',
        idMedico: 1
      },
      submit: false,
      error: false,
      success: false
    };
  },
  computed: {
    validation: function () {
      return {
        paciente: !!this.form.paciente.trim(),
        dataConsulta: !!this.form.dataConsulta.trim(),
        observacao: !!this.form.observacao.trim()
      };
    }
  },
  methods: {
    resetFields: function () {
      for (var i in this.form) {
        this.form[i] = i == "idMedico" ? 1 : '';
      }

      this.submit = false;
    },
    enroll: function () {
      this.submit = true;

      if (this.isValid) {
        const obj = JSON.stringify(this.form);
        this.$root.resquestEnroll(obj, this.successEnroll, this.failEnroll);
      }
    },
    successEnroll: function () {
      var self = this;
      console.log('Exiba a mensagem de sucesso :D');
      self.success = true;
      self.resetFields();
      setTimeout(function () {
        self.success = false;
      }, 5000);
    },
    failEnroll: function () {
      this.error = true;
      console.error('Erro ao tentar cadastrar');
    }
  }
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ })
/******/ ]);